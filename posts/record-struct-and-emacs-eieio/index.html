<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-10-10 Sun 18:13 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>record, struct and emacs eieio</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="include-yy" />
<link rel="stylesheet" type="text/css" href="../../css/style_gongzhitaao.css" />
<link rel="icon" type="image/x-icon" href="../../img/kagamine_rin.ico">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="http://www.incf19.com"> HOME </a>
</div><div id="preamble" class="status">
<div>
  <a href="http://www.incf19.com/index.html">Go Home </a>
  <hr class="Solid">
</div>
</div>
<div id="content">
<h1 class="title">record, struct and emacs eieio</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7bb36fa">1. record 和 cl-defstruct</a>
<ul>
<li><a href="#org976ba9f">1.1. 用于定义结构的 cl-defstruct</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本文的目的是对 elisp 中的结构（也叫 record）做一个介绍，顺便介绍在此之上的 elisp 面向对象系统 —— eieio。除了讲一讲它们的使用说明外，本文还会在面向对象这个词上花点功夫，或者说谈谈我对于面向对象编程的理解。
</p>

<p>
我用过的“典型”面向对象语言仅有 C++ 和 python，本文中多数面向对象例子都使用这两种语言。由于我在面向对象编程方面的经验少的可怜，若出现比较幼稚的代码和用语还请多多包涵。
</p>

<p>
下文中出现的观点仅代表我个人看法，若有不同见解欢迎与我交流。
</p>

<p>
使用环境： emacs on windows 27.1
</p>

<div id="outline-container-org7bb36fa" class="outline-2">
<h2 id="org7bb36fa"><span class="section-number-2">1</span> record 和 cl-defstruct</h2>
<div class="outline-text-2" id="text-1">
<p>
record 可以用来创建 emacs 中没有的类型的对象。它们用作 cl-defstruct 和 eieio 中 defclass 的内部表示。
</p>

<p>
record 和 vector 非常像，可以使用 aref 来访问它的 slot（段），使用 copy-sequence 来获取浅拷贝。它的第一个 slot 存储了类型，可以使用 <code>type-of</code> 获取。根据文档，在当前实现中（emacs 27.2），一个 record 最多可以有 4096 个 slot。
</p>

<p>
record 的类型必须是一个 symbol 或类型描述符（type descriptor）。
record 的打印表示是 <code>#s</code> 加上各 slot 的打印表示。record 是自求值的（self-evaluating form），对某个 record 求值会得到与之相同的 record。
</p>

<p>
为了避免和其他类型出现名字冲突，定义新类型的 Lisp 程序应该使用 package 的命名规范。
</p>

<p>
与 record 相关的函数就三个，判断对象是否为 record 的 <code>recordp</code> 和用于创建 record 的 <code>record</code> 与 <code>make-record</code> 。其中， <code>record</code> 和 <code>make-record</code> 的关系就像是 <code>list</code> 和 <code>make-list</code> 一样。
</p>

<p>
下面是一些简单的例子，用作对上面文字的简单说明：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(recordp #s(a 1)) =&gt; t
(recordp [a 1]) =&gt; nil

(record 'yy-record 1 2 3) =&gt; #s(yy-record 1 2 3)
(make-record 'yy-record 5 0) =&gt; #s(yy-record 0 0 0 0 0)
</pre>
</div>
</div>

<div id="outline-container-org976ba9f" class="outline-3">
<h3 id="org976ba9f"><span class="section-number-3">1.1</span> 用于定义结构的 cl-defstruct</h3>
<div class="outline-text-3" id="text-1-1">
<p>
既然这个宏的名字有 cl 前缀，那它自然是从 common lisp 中借过来的了。它提供了一种定义结构体的通用方法。在 r6rs 中有一个叫做 <code>define-record-type</code> 的宏（或者说 syntax extension）和 cl-defstruct 很像，它大概也是受到了 CL 的影响。 <code>define-record-type</code> 最早出现在 SRFI9<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>中。
</p>

<p>
cl-defstruct 使用 record 作为内部的数据对象表示方法。emacs 早先版本中没有 record 的时候使用的是另外的表示方法，使用旧版本 emacs 编译的代码中含有 cl-defstruct 的部分不会使用 record。emacs 提供了一个叫做 <code>cl-old-struct-compat-mode</code> 的函数来兼容先前版本，若编译码中含有旧的 cl-defstruct，就会激活该模式来提供兼容支持。
</p>

<p>
<code>cl-defstruct</code> 的原型是：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> <span style="color: #18b2b2;">name</span> slots ...)
</pre>
</div>

<p>
其中 name 是要定义结构的名称，slots 是结构各个 slot 的名字。在求值后，cl-defstruct 会默认为你生成一些函数： <code>make-name</code> 可以用来构建新的类型为 name 的对象， <code>copy-name</code> 可以获取某个 name 对象的浅拷贝， <code>name-p</code> 可以判断某个对象是否为 name 结构， <code>name-{slot-name}</code> 可以获取某个 name 对象的某 slot 的值。使用 <code>(setf (name-{slot-name} obj) newval)</code> 可以为对象的某个 slot 赋值。
</p>

<p>
<code>make-name</code> 接受以 slots name 作为关键字的关键字参数，若调用函数时存在没有指定的 slot，那么得到的对象中该 slot 的值为 nil。各种 getter 函数在获取 slot 值之前会判断对象的类型，若类型不符则引发错误。
</p>

<p>
下面的例子可以说明上述函数的使用：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> <span style="color: #18b2b2;">website</span> domain ip)
(<span style="color: #00af00;">setq</span> a (make-website <span style="color: #b218b2;">:domain</span> <span style="color: #ff1f8b;">"baidu.com"</span> <span style="color: #b218b2;">:ip</span> <span style="color: #ff1f8b;">"220.181.38.148"</span>))
(website-domain a) =&gt; <span style="color: #ff1f8b;">"baidu.com"</span>
(website-ip a) =&gt; <span style="color: #ff1f8b;">"220.181.38.148"</span>
(<span style="color: #00af00;">setq</span> b (copy-website a)) =&gt; #s(website <span style="color: #ff1f8b;">"baidu.com"</span> <span style="color: #ff1f8b;">"220.181.38.148"</span>)

(<span style="color: #00af00;">setq</span> c (make-website <span style="color: #b218b2;">:domain</span> <span style="color: #ff1f8b;">"zhihu.com"</span>)) =&gt; #s(website <span style="color: #ff1f8b;">"zhihu.com"</span> nil)
(<span style="color: #00af00;">setf</span> (website-ip c) <span style="color: #ff1f8b;">"103.41.167.234"</span>)
c =&gt; #s(website <span style="color: #ff1f8b;">"zhihu.com"</span> <span style="color: #ff1f8b;">"103.41.167.234"</span>)
</pre>
</div>

<p>
<code>cl-defstruct</code> 的 slot 除了是单个 slot-name 外，还可以是 <code>(slot-name default-value slot-options ...)</code> 的形式。 <code>default-value</code> 是一个表达式，每当创建实例但未指定 slot-name 的值时对该表达式求值，使用求值结果作为默认值。 <code>slot-options</code> 可以是 <code>:read-only</code> ， <code>:type</code> 和 <code>:documentation</code> 三个，其他的选项会被忽略掉。 <code>:raed-only</code> 表示该 slot 的值在对象创建时就确定，且随后不能被 setf 修改。 <code>:type</code> 用来指定 slot 的值类型，不过对于动态类型的 elisp 大概就图一乐。 <code>:documentation</code> 是描述 slot 的字符串。
</p>

<p>
使用 list 形式的 slot，我们可以改进上面的代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> <span style="color: #18b2b2;">website3</span> (domain <span style="color: #ff1f8b;">""</span> <span style="color: #b218b2;">:type</span> string <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"domain of webiste"</span>)
                       (ip <span style="color: #ff1f8b;">""</span> <span style="color: #b218b2;">:type</span> string <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"ip of host"</span>))
</pre>
</div>
</div>

<div id="outline-container-org5559165" class="outline-4">
<h4 id="org5559165"><span class="section-number-4">1.1.1</span> 其他选项</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
除了说 slot 具有选项外，整个结构也有一些关键字可用。它的出现方式与 slot 的选项类似，以单个符号出现或包括选项的表出现。
</p>

<p>
以下选项是可用的：
</p>

<ul class="org-ul">
<li><code>:conc-name</code> 这个选项用来指定作为 getter 函数前缀的名字，默认情况下这个前缀是结构名加上一个 <code>-</code> 。如果指定 nil 的话，getter 函数名就是各 slot 的名字。</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">yyyy</span> (<span style="color: #b218b2;">:conc-name</span> y4-)) a b c)
(y4-a (make-yyyy <span style="color: #b218b2;">:a</span> 1)) =&gt; 1

(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">yyyyy</span> (<span style="color: #b218b2;">:conc-name</span> nil)) yy-a b c)
(yy-a (make-yyyyy <span style="color: #b218b2;">:yy-a</span> 1)) =&gt; 1
</pre>
</div>

<ul class="org-ul">
<li><code>:constructor</code> 用来指定构造函数的名字，它可以多次使用来指定不同的构造函数。它有两种用法：
<ul class="org-ul">
<li>简单的就是 <code>(:constructor new-name)</code> ，可以使用 <code>new-name</code> 而不是 <code>make-{structname}</code> 来作为构造函数的名字。如果指定 nil，那就不生成默认的构造函数。</li>
<li>更复杂的用法则是指定构造名和相应的参数表。参数表中可以使用 CL 风格的参数，即 &amp;optional，&amp;rest，&amp;key 和 &amp;aux。参数表中与 slot 名字对应的参数会将它的值赋给对应的 slot。若某 slot 名字没有出现在参数表中，它在对象中的值就是 slot 指定的默认值或 nil。若对应于某 slot 的 &amp;optional 参数被忽略了，slot 的值就是 &amp;optional 的默认值或 slot 的默认值。</li>
</ul></li>
</ul>

<p>
以下例子可以说明上面的用法：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">y6</span> (<span style="color: #b218b2;">:constructor</span> y6-make)) a b c)
(y6-a (y6-make <span style="color: #b218b2;">:a</span> 1)) =&gt; 1

(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">y7</span> (<span style="color: #b218b2;">:constructor</span> nil)
                  (<span style="color: #b218b2;">:constructor</span> y7-c1 (a b c))
                  (<span style="color: #b218b2;">:constructor</span> y7-c2 (<span style="color: #18b2b2;">&amp;key</span> a b c))
                  (<span style="color: #b218b2;">:constructor</span> y7-c3 (x y z <span style="color: #18b2b2;">&amp;aux</span> (a x) (b y) (c z)))
                  (<span style="color: #b218b2;">:constructor</span> y7-c4 (a <span style="color: #18b2b2;">&amp;optional</span> (b (+ a 1)) (c 0)))
                  (<span style="color: #b218b2;">:constructor</span> y7-c5 (b a <span style="color: #18b2b2;">&amp;rest</span> c0 <span style="color: #18b2b2;">&amp;aux</span> (c (car c0)))))
  a b c)

(make-y7) =&gt; Debugger entered--Lisp error: (void-function make-y7)
(y7-c1 1 2 3) =&gt; #s(y7 1 2 3)
(y7-c2 <span style="color: #b218b2;">:a</span> 1 <span style="color: #b218b2;">:b</span> 2 <span style="color: #b218b2;">:c</span> 3) =&gt; #s(y7 1 2 3)
(y7-c3 1 2 3) =&gt; #s(y7 1 2 3)
(y7-c4 1) =&gt; #s(y7 1 2 0)
(y7-c4 1 0) =&gt; #s(y7 1 0 0)
(y7-c4 1 3 3) =&gt; #s(y7 1 3 3)
(y7-c5 1 2) =&gt; #s(y7 2 1 nil)
(y7-c5 1 2 3 4) =&gt; #s(y7 2 1 3)

(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">y8</span> (<span style="color: #b218b2;">:constructor</span> y8-c (a <span style="color: #18b2b2;">&amp;optional</span> b)))
  a (b 123 <span style="color: #ff1f8b;">"hhh"</span>))

(y8-c 1) =&gt; #s(y8 1 123)
(y8-c 1 2) =&gt; #s(y8 1 2)
</pre>
</div>

<ul class="org-ul">
<li><code>:copier</code> ，为浅拷贝函数提供一个名字，默认情况下是 <code>copy-{name}</code> ，若指定 nil 则不生成默认拷贝函数。（拷贝函数使用 copy-sequence 实现）</li>

<li><code>:predicate</code> ，为该类型的判断谓词提供一个名字。默认情况下是 <code>{name}-p</code> ，若指定 nil 则不会生成谓词函数。（如果使用了 :type 且没有指定 :named 选项的话也会没有谓词函数）
<ul class="org-ul">
<li><code>cl-typep</code> 接受一个值和类型来判断值是否为该类型。它会使用 <code>typename-p</code> 来判断是否为该类型。若使用 <code>:predicate</code> 指定了其他的谓词名字， <code>cl-typep</code> 就用不了了。不过就下面例子中定义的 yy-11 来看，指定了其他名字作为谓词，cl-typep 也可以正常工作。（可能是文档滞后了）</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">example of common use</span>
(cl-typep 'a 'atom) =&gt; t
(<span style="color: #00af00;">and</span> (cl-typep nil 'atom) (cl-typep nil 'list)) =&gt; t
(cl-typep 'a 'symbol) =&gt; t
(cl-typep 1 'integer) =&gt; t
(cl-typep 1.0 'float) =&gt; t
(cl-typep 1 'number) =&gt; t
(cl-typep ?a 'character) =&gt; t
(cl-typep <span style="color: #ff1f8b;">"abc"</span> 'string) =&gt; t
(cl-typep [1 2] 'vector) =&gt; t
(cl-typep [] 'array) =&gt; t
(cl-typep '(1) 'list) =&gt; t
(cl-typep '(1 2) 'cons) =&gt; t
(cl-typep [1 2 3] 'sequence) =&gt; t
(cl-typep (make-hash-table) 'hash-table) =&gt; t
(cl-typep #s(1 2) 'record) =&gt; t

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">cl-typep with struct</span>
(<span style="color: #00af00;">cl-defstruct</span> <span style="color: #18b2b2;">yy-9</span> a)
(cl-typep (make-yy-9 <span style="color: #b218b2;">:a</span> 1) 'yy-9) =&gt; t
(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">yy-11</span> (<span style="color: #b218b2;">:predicate</span> huhu)) a)
(cl-typep (make-yy-11 <span style="color: #b218b2;">:a</span> 1) 'yy-11) =&gt; t
</pre>
</div>

<ul class="org-ul">
<li><code>:include</code> ，可以将其他结构中的 slot 包含到该结构中，类似于 C++ 中的继承操作，它接受一个结构名作为参数。父结构的 getter 函数可以用在子结构上。
<ul class="org-ul">
<li>如果结构名后面还有参数，那么它会替换掉原结构中 slot 的选项</li>
<li>该选项只能使用一次，这也就是说只允许“单继承”</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> <span style="color: #18b2b2;">yy-father</span> a (b 0) c)
(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">yy-son</span> (<span style="color: #b218b2;">:include</span> yy-father (b 1)))
  d e)
(yy-father-a (make-yy-son <span style="color: #b218b2;">:a</span> 1 <span style="color: #b218b2;">:b</span> 2 <span style="color: #b218b2;">:c</span> 3 <span style="color: #b218b2;">:d</span> 4 <span style="color: #b218b2;">:e</span> 5)) =&gt; 1
(yy-father-b (make-yy-son)) =&gt; 1
(yy-father-b (make-yy-father)) =&gt; 0

</pre>
</div>

<ul class="org-ul">
<li><code>:noinline</code> ，使用该选项说明结构的函数不会是内联（inline）的，即使一般情况下是</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara"><a href="https://srfi.schemers.org/srfi-9/">https://srfi.schemers.org/srfi-9/</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr class="Solid">
<p>Create Date: 2021-10-09 Sat 17:04</p> <p>Last modified: 2021-10-10 Sun 17:26</p>
<p>Creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>

<p style="text-align:center;">
  <a href="https://beian.miit.gov.cn/">京ICP备2021021729号</a>
</p>

<p style="text-align:center;">
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
  </a><br />
  本作品采用
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    知识共享署名 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
</body>
</html>
