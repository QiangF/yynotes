<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-10-25 Mon 20:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>蝴蝶效应与 emacs 动画 <div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzg1Nzc4NTQ1.jpg" alt="load failed"></div></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="include-yy" />
<link rel="stylesheet" type="text/css" href="../../css/style_gongzhitaao.css" />
<link rel="icon" type="image/x-icon" href="../../img/kagamine_rin.ico">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="http://www.incf19.com"> HOME </a>
</div><div id="preamble" class="status">
<div>
  <a href="http://www.incf19.com/index.html">Go Home </a>
  <hr class="Solid">
</div>
</div>
<div id="content">
<h1 class="title">蝴蝶效应与 emacs 动画 <div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzg1Nzc4NTQ1.jpg" alt="load failed"></div></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org282a81d">1. emacs 与蝴蝶效应</a></li>
<li><a href="#orge9c7c62">2. emacs 的 animate.el</a>
<ul>
<li><a href="#org274f9cc">2.1. 什么是动画</a></li>
<li><a href="#org5e1a827">2.2. animation.el 的具体实现</a></li>
</ul>
</li>
<li><a href="#orge397a7b">3. 使用 emacs 的 buffer 显示字符流</a>
<ul>
<li><a href="#orgea61939">3.1. 如何将视频转为文本</a></li>
<li><a href="#org8d4e796">3.2. 如何在 emacs 中“播放”文本</a></li>
<li><a href="#org9cd6e82">3.3. 一个五年前的 bad apple on emacs</a></li>
<li><a href="#orge7a0929">3.4. 总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
从这个标题你就应该知道了这不是什么正经的技术文章。本文就偶然发现的 emacs butterfly 命令来谈谈 emacs 中如何使用 animate.el 实现简单的动画效果，最后使用经典的 bad apple 来展示一个简单的动画。 bad apple 和 animate.el 的关系可能不是很大了，放在这里仅图一乐。
</p>

<p>
本文使用的编程环境是 emacs 27.1 on windows
</p>

<div id="outline-container-org282a81d" class="outline-2">
<h2 id="org282a81d"><span class="section-number-2">1</span> emacs 与蝴蝶效应</h2>
<div class="outline-text-2" id="text-1">
<p>
从 emacs-china 的<a href="https://emacs-china.org/t/real-programmers-use-butterfly/15599">这个帖子</a>我了解到了 emacs 还提供了 butterfly 这个奇怪又有趣的命令，它是针对下面的 xkcd 漫画<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>的：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./real_programmers.png" alt="real_programmers.png" /></td>
</tr>
</tbody>
</table>

<p>
这里对图中的文字做一点简单的翻译：
</p>

<blockquote>
<ol class="org-ol">
<li>你在用 nano？真正的程序员用的是 emacs</li>
<li>嗨， <b>真正</b> 的程序员用的是 vim</li>
<li>切， <b>真正</b> 的程序员用 ed</li>
<li>不对，真正的程序员用 cat</li>
<li>真正的程序员用的是一根磁针和稳定的手</li>
<li>打扰一下，虽然但是，真正的程序员是用蝴蝶编程的</li>
<li>他们张开双手，让蝴蝶的翅膀扑腾一下</li>
<li>扰动的涟漪向外扩散，改变了高层大气中漩涡的流动</li>
<li>漩涡成为宇宙射线的透镜，将它们聚集以撞击磁盘，并翻转期望的位</li>
<li>听上去不错，Emacs 中有一个命令来完成它
<ul class="org-ul">
<li>哦耶，C-x M-c M-butterfly&#x2026;&#x2026;</li>
<li>（实际上是 M-x butterfly）</li>
</ul></li>
</ol>
</blockquote>

<p>
上面的漫画讲了个冷笑话，使用蝴蝶效应影响宇宙射线来进行编程。这听起来比使用只有 0 和 1 两个按键的键盘编程更离谱。至于是先有这个漫画还是先有 butterfly 这个玩具命令，答案是显而易见的，不过这条命令是什么时候被加入到 emacs 中的呢？
</p>

<p>
这个可以通过查看 misc.el 的 commit 记录来得知（又到了我最喜欢的 emacs 考古时间）。从<a href="https://github.com/emacs-mirror/emacs/commit/e8d24e5b0960898e4a93ee2918f677b375b68263#diff-bf62448d8061c082224bd88d2c8bb8e2ddac30f67d47b4f2c9b1f96fe42d5ecf">这个commit</a>来看，butterfly 最早出现在 2008 年 12 月 29 日的一次提交，提交者是 link0ff（Juri Linkov）。最初的版本只是使用 message 显示几条好笑的消息，后续版本在新 buffer 中使用动画效果来绘制文字。查看 emacs 的 commit 历史可以发现 link0ff 是非常活跃的，作为核心成员加一些有趣的代码也许并不是什么奇怪的事情。
</p>

<p>
下面就是 butterfly 命令的显示效果了：
</p>

<p>
<div class="yyheadimg"><img src="./1.gif" alt="load failed"></div>
</p>

<p>
当然，在闲的蛋疼的时候发现这个命令的人显然不止我一个（更何况我还是在别人的帖子里看到的），<a href="https://sachachua.com/blog/2013/06/animating-things-in-emacs/">Sacha Chua</a> 也是在某次无聊的浏览命令中发现了这个命令，我在她的博客中发现了一个和 emacs 有关的简单动画教程，感兴趣的同学可以去看看：<a href="http://dantorop.info/project/emacs-animation/">emacs lisp animations</a>
</p>

<p>
玩的也差不多了，下面我们来看看这个简单的动画效果是如何实现的，以及如何使用它来做一些其他的事情。
</p>
</div>
</div>


<div id="outline-container-orge9c7c62" class="outline-2">
<h2 id="orge9c7c62"><span class="section-number-2">2</span> emacs 的 animate.el</h2>
<div class="outline-text-2" id="text-2">
<p>
这个库的第一次 commit 时间是 2001 年 1 月 23 日，它的主要功能是动画显示“祝你生日快乐”，也就是在 buffer 中输出一些好玩的诗句。感兴趣的同学可以试试 <code>M-x animate-birthday-present</code> ，然后输入你的名字，它会在 buffer 中输出一些祝福，字符是从四面八方飞过来再摆放好的。
</p>

<p>
举例来说，当我输入 include-yy 时，得到的就是如下字符串：（我仔细的看了一下，下面的祝福从第一次 commit 以来就没有变过）
</p>

<pre class="example">
Happy Birthday,
Include-Yy


   You are my sunshine,
   My only sunshine.
   I'm awful sad that
   You've moved away.

   Let's talk together
   And love more deeply.
   Please bring back
   my sunshine
   to stay!
</pre>

<p>
当然，我们关注的是它的实现方法，也就是它通过什么方法实现了字符的动态摆放。下面我就 animate.el 的代码实现进行一些简单的分析。这个文件只有 200 多行 elisp 代码，除去“祝你生日快乐”的部分，那就只剩下 150 行左右了。
</p>
</div>

<div id="outline-container-org274f9cc" class="outline-3">
<h3 id="org274f9cc"><span class="section-number-3">2.1</span> 什么是动画</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在正式开始之前，我们不妨来了解一下动画（animation）这个词的含义。
</p>

<p>
以下部分的内容来自维基百科<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>：
</p>

<blockquote>
<p>

</p>

<p>
动画是通过操作图像来展示运动图像的一种方法。在传统动画中，图像是在透明的赛璐珞（Celluloid sheet）上手绘的，以供拍摄或展示在胶片上。今天的大多数动画都使用计算机生成图像（CGI）。计算机动画（Computer animation）可以是非常写实（very detailed）的 3D 动画，而 2D 动画可用于低带宽或更快的实时渲染。
</p>

<p>
一般来说，动画效果是通过快速的图像序列来实现的，连续的图像彼此的差异非常小。动画比许多人所知的更普遍。除了短片，故事片，电视剧，动画 gif 和其他专门用于显示运动图像的媒体外，动画在视频游戏，动态图形，用户界面和视觉效果中也很普遍。
</p>
</blockquote>

<p>
在维基百科中使用了这样的例子来说明一个弹球动画的产生：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./2.png" alt="2.png" /></td>
<td class="org-left"><img src="./3.gif" alt="3.gif" /></td>
</tr>
</tbody>
</table>

<p>
除了动画，有时候我们还会听到“动漫”这个词，它应该是动画和漫画的统称，不过现在大多数人似乎直接将它和日本动画视为同一事物了（包括我）。日本动画也是有它的特指单词的，即 anime<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>。
</p>

<p>
我本人并非什么资深动画爱好者或是动画历史学家，关于动画的历史，发展和现状可以参考其他更加细致的文章或书籍。这里简单列出一些我认为值得一读的文章：
</p>

<ul class="org-ul">
<li><a href="https://history-of-animation.webflow.io/">https://history-of-animation.webflow.io/</a></li>

<li><a href="https://zhuanlan.zhihu.com/p/35055431">浅谈世界动画片发展史：从1900至1950年，那些属于动画大师的荣光</a></li>
</ul>

<p>
下文中出现的动画一词指的就是“看起来很连贯的图像序列”，这个定义算不上严谨，不过对本文来说绝对够用了。
</p>
</div>
</div>


<div id="outline-container-org5e1a827" class="outline-3">
<h3 id="org5e1a827"><span class="section-number-3">2.2</span> animation.el 的具体实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在开始具体的代码分析之前，我们首先要知道这个库到底干了什么。在上面的 <code>butterfly</code> 中我们看到字符从窗口的各个位置“飞”到了它的最终位置，并组成了一句话。其实这也就是这个库的全部功能了：把一个字符串打散到 buffer 各处，然后让它们飞回约定的位置。下面就“打散”和“飞回”两部分来分析代码。
</p>
</div>

<div id="outline-container-org43899c5" class="outline-4">
<h4 id="org43899c5"><span class="section-number-4">2.2.1</span> 如何打散字符串</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
animate.el 提供了 animate-initialize 这个函数来打散字符串。它接受一个字符串和两个整数作为参数，并返回包括打散字符信息的表。它的第二参数和第三参数分别是字符串首字符的垂直位置和水平位置。字符串中的首字符的最终位置就是 (VPOS,HPOS)，它后面的字符就是 (VPOS, HPOS + 1)，后面依次水平坐标加一。至于它们的初始位置则由随机函数得到，这个位置与窗口的大小有关。
</p>

<p>
具体的实现代码如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">animate-initialize</span> (string vpos hpos)
  (<span style="color: #00af00;">let</span> ((characters nil))
    (<span style="color: #00af00;">dotimes</span> (i (length string))
      (<span style="color: #00af00;">setq</span> characters
            (cons (list (aref string i)
                        <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">Random starting positions.</span>
                        (random (window-height))
                        (random (1- (window-width)))
                        <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">All the chars should end up</span>
                        <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">on the specified line.</span>
                        vpos
                        <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">The Ith character in the string</span>
                        <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">needs to end up I positions later.</span>
                        (+ hpos i))
                  characters)))
    characters))
</pre>
</div>

<p>
可以看到，原字符串中的字符对应于返回值表中的一个表元素，表首元素是字符值，随后的四个元素是初始垂直位置，初始水平位置，最后垂直位置，最后水平位置。举例来说的话，我要将 "hello" 放在第 1 行第 2 列，得到的返回值如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(reverse
 (<span style="color: #00af00;">cl-loop</span>
  for a in (animate-initialize <span style="color: #ff1f8b;">"hello"</span> 1 2)
  collect (<span style="color: #00af00;">-let</span> (((a0 a1 a2 a3 a4) a))
            (format <span style="color: #ff1f8b;">"%c (%s,%s) -&gt; (%s,%s)"</span> a0 a1 a2 a3 a4))))
(<span style="color: #ff1f8b;">"h (10,5) -&gt; (1,2)"</span>
 <span style="color: #ff1f8b;">"e (11,46) -&gt; (1,3)"</span>
 <span style="color: #ff1f8b;">"l (7,107) -&gt; (1,4)"</span>
 <span style="color: #ff1f8b;">"l (16,93) -&gt; (1,5)"</span>
 <span style="color: #ff1f8b;">"o (4,56) -&gt; (1,6)"</span>)
</pre>
</div>

<p>
上面的第一个坐标就是随机生成的初始位置，第二个坐标就是最终位置。在返回值中字符顺序与原字符串是相反的。
</p>

<p>
既然获得了字符的坐标，那么我们就要把它画出来。这个工作可以通过 <code>animate-place-char</code> 来完成，它接受字符、垂直位置和水平位置三个参数，并把字符放到当前 buffer 对应的位置。
</p>
</div>
</div>


<div id="outline-container-orgb89bf56" class="outline-4">
<h4 id="orgb89bf56"><span class="section-number-4">2.2.2</span> 如何动态“移动字符”</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
通过随机函数，我们就得到了各字符的起始坐标和终止坐标，接下来就要将字符从初始位置移动到终止位置。移动的方式是多种多样的，animate.el 选择了最简单的方式，即沿直线从一端到另一端。要体现出移动过程的话，就需要在直线上多次绘制字符，直到到达目的地为止。若有两点 \(x1, y1 \) 和 \(x2, y2 \) ，那么我们可以用中间点到初始点的距离与线段长的比来表示它在线段上的为止。若用 \(\alpha \) 表示比例，则有：
</p>

<p>
\((x, y) = \alpha(x2 - x1, y2 - y1) + (x1, y1) = ((1 - \alpha)x1 + \alpha x2, (1 - \alpha) y1 + \alpha y2) \)
</p>

<p>
通过以上公式可以算出中间点的位置。 <code>animate-step</code> 接受一个字符位置序列和一个比值，比值就是中间点的比例值，它为 0 则说明在初始点，为 1 则说明在终点，为 0 到 1 之间的值则在线段中。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">animate-step</span> (characters fraction)
  (<span style="color: #00af00;">let</span> ((remains (- 1 fraction)))
    (<span style="color: #00af00;">dolist</span> (item characters)
      (<span style="color: #00af00;">let</span> ((vpos (+ (* remains (nth 1 item))
                     (* fraction (nth 3 item))))
            (hpos (+ (* remains (nth 2 item))
                     (* fraction (nth 4 item)))))
        (animate-place-char (car item) vpos hpos)))))
</pre>
</div>

<p>
既然动画是图片序列形成的，那么每张图片之间需要有一个较短的时间间隔，而且还需要确定图片的数量，图片的张数乘以图片之间的时间间隔就是动画的总时长。在 animate.el 中给出了一个 option 来控制从起始点到终点的移动步数，它的默认值是 10。
</p>
</div>
</div>


<div id="outline-container-org7ac44a0" class="outline-4">
<h4 id="org7ac44a0"><span class="section-number-4">2.2.3</span> 高级的接口函数</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
利用上面的这些函数就足够我们写出从零散字符到通顺字符串的动画效果了，比如这样：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">let</span> ((buf (get-buffer-create <span style="color: #ff1f8b;">"*yy*"</span>)))
  (switch-to-buffer buf)
  (erase-buffer)
  (<span style="color: #00af00;">let*</span> ((steps 10)
         (chars (append (animate-initialize <span style="color: #ff1f8b;">"&#38745;&#22812;&#24605;"</span> 1 5)
                        (animate-initialize <span style="color: #ff1f8b;">"&#26446;&#30333;"</span> 2 7)
                        (animate-initialize <span style="color: #ff1f8b;">"&#24202;&#21069;&#26126;&#26376;&#20809;"</span> 3 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#30097;&#26159;&#22320;&#19978;&#38684;"</span> 4 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#20030;&#22836;&#26395;&#26126;&#26376;"</span> 5 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#20302;&#22836;&#24605;&#25925;&#20065;"</span> 6 3)))
         (blanks (mapcar (<span style="color: #00af00;">lambda</span> (x) (cons ?   (cdr x))) chars)))

    (<span style="color: #00af00;">dotimes</span> (i steps)
      (animate-step chars (/ i 1.0 steps))
      (sit-for 0.5)
      (animate-step blanks (/ i 1.0 steps)))
    (animate-step chars 1)))
</pre>
</div>

<p>
上面代码的思路非常简单，那就是在 buffer 上逐步打印从起始点到终点的字符，并使用位置相同的空字符擦除先前的字符。但是这样的代码是存在问题的，如果你在你的 emacs 中尝试一下就会发现存在没有被擦除的汉字。这是因为汉字的宽度是 2，它在 buffer 中要占两列，使用英文空格清除会出现问题。即使你把英文空格更改为全角空格 <code>?\u3000</code> 貌似也会出问题。
</p>

<p>
animate.el 中的 <code>animate-string</code> 函数巧妙地避免了这个问题，在输出一次后，它通过撤销上一次输出而不是使用空白字符覆盖来达到清屏的目的。由于它的代码稍长，这里只列出撤销动作的实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">dotimes</span> (i animate-n-steps)
      <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">Bind buffer-undo-list so it will be unchanged when we are done.</span>
      <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">(We're going to undo all our changes anyway.)</span>
      (<span style="color: #00af00;">let</span> (buffer-undo-list
            list-to-undo)
       <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">....... do some draw</span>
       (sit-for .05) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">pause 0.05s</span>
       (<span style="color: #00af00;">setq</span> list-to-undo buffer-undo-list)
        (<span style="color: #00af00;">while</span> list-to-undo
          (<span style="color: #00af00;">let</span> ((undo-in-progress t))
            (<span style="color: #00af00;">setq</span> list-to-undo (primitive-undo 1 list-to-undo))))))
</pre>
</div>

<p>
上面使用变量 <code>buffer-undo-list</code> 记录下撤销信息，在某次绘制完成后的间隔，通过 undo 命令将绘制的字符全部撤销掉，以此完成清屏。
</p>

<p>
按照这个思路，我们可以对上面的《静夜思》进行修正：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">let</span> ((buf (get-buffer-create <span style="color: #ff1f8b;">"*yy*"</span>)))
  (switch-to-buffer buf)
  (erase-buffer)
  (<span style="color: #00af00;">let*</span> ((steps 10)
         (chars (append (animate-initialize <span style="color: #ff1f8b;">"&#38745;&#22812;&#24605;"</span> 1 5)
                        (animate-initialize <span style="color: #ff1f8b;">"&#26446;&#30333;"</span> 2 7)
                        (animate-initialize <span style="color: #ff1f8b;">"&#24202;&#21069;&#26126;&#26376;&#20809;"</span> 3 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#30097;&#20284;&#22320;&#19978;&#38684;"</span> 4 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#20030;&#22836;&#26395;&#26126;&#26376;"</span> 5 3)
                        (animate-initialize <span style="color: #ff1f8b;">"&#20302;&#22836;&#24605;&#25925;&#20065;"</span> 6 3))))
    (<span style="color: #00af00;">let</span> (buffer-undo-list
          list-to-undo)
      (<span style="color: #00af00;">dotimes</span> (i steps)
        (animate-step chars (/ i 1.0 steps))
        (sit-for 0.01)
        (<span style="color: #00af00;">setq</span> list-to-undo buffer-undo-list)
        (<span style="color: #00af00;">while</span> list-to-undo
          (<span style="color: #00af00;">let</span> ((undo-in-progress t))
          (<span style="color: #00af00;">setq</span> list-to-undo (primitive-undo 1 list-to-undo))))))
    (animate-step chars 1)))

</pre>
</div>

<p>
得到的效果图如下：
</p>

<p>
<div class="yyheadimg"><img src="./4.gif" alt="load failed"></div>
</p>

<p>
除了 <code>animate-string</code> ，还有一个叫做 <code>anmiate-sequence</code> 的函数，它接受一个字符串表和一个表示字符串间空行数的整数，若第二参数为 0，则字符串表中的字符串空行数为 0。它将字符串表中的字符串逐串打印到buffer 中，若 <code>animation-buffer-name</code> 的值为 nil，则默认打印到 <code>*Animation*</code> buffer 中。下面我们使用一个 ascii 艺术作为例子演示 <code>animate-sequence</code> 的使用：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">setq</span> a
      '(
        <span style="color: #ff1f8b;">"[bug]     /\"*._         _"</span>
        <span style="color: #ff1f8b;">"      .-*'`    `</span><span style="color: #1f5bff;">*-.._.-</span><span style="color: #ff1f8b;">'/"</span>
        <span style="color: #ff1f8b;">"    &lt; * ))     ,       ("</span>
        <span style="color: #ff1f8b;">"      `*-._`._(__.--*\"`.\\"</span>
        ))
<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">https://www.asciiart.eu/animals/fish</span>
(animate-sequence a 0)
</pre>
</div>

<p>
本来我想使用 touhou 相关的 ascii 艺术，但是它们大多使用了日语，在 emacs 的显示效果非常奇怪，想想还是算了。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./5.PNG" alt="5.PNG" /></td>
<td class="org-left"><img src="./6.png" alt="6.png" /></td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org8e99cb6" class="outline-4">
<h4 id="org8e99cb6"><span class="section-number-4">2.2.4</span> 关于上面函数的一些改进</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
使用 <code>animate-sequence</code> 虽然可以方便地显示多个字符串，但是它内部调用的是 <code>animate-string</code> ，所以它的动画是由每个字符串的单独动画组成的，只有一个字符串的动画完成后才会进行下一个字符串的动画显示。这个函数是没有办法达到我上面的《静夜思》一下子显示所有字符的显示效果的。同时， <code>animate-string</code> 的间隔时间固定是 50 毫秒，它没有办法通过函数参数来变更。针对这两个问题，我们可以通过添加新的高级函数来解决。以下是我编写的几个辅助函数，它们包括：
</p>

<ul class="org-ul">
<li>变量 <code>animate-dtime</code> ，控制每幅图像间的时间间隔</li>
<li><code>(animate-init* S1 &amp;rest S)</code> ，它接受多个字符信息，并生成包含每个字符的初末位置信息的表，是对 <code>animate-initialize</code> 的强化</li>
<li><code>(animate-initn SN VPOS HPOS)</code> ，它接受单个字符串，字符串中间的换行符作为不同字符串的分隔。最后得到串中每个字符的初末位置信息表</li>
<li><code>(animate-chars CHARS)</code> ，接受一个字符信息表，生成它们的动画</li>
<li><code>(animate-str* LS &amp;optional VPOS HPOS)</code> ，接受多个字符串信息，并使它们同时进行动画</li>
<li><code>(animate-strn S VPOS &amp;optional HPOS)</code> ，接受单个字符串，使用 '\n' 来判断字符串是否换行</li>
</ul>


<p>
它们解决的问题是：
</p>

<ul class="org-ul">
<li>一次可以显示多行字符串的动画</li>
<li>可以对间隔时间进行控制</li>
</ul>

<p>
以下是实现代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defvar</span> <span style="color: #ff8700;">animate-dtime</span> 0.05)

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">animate-init*</span> (s1 <span style="color: #18b2b2;">&amp;rest</span> s)
  (<span style="color: #00af00;">let</span> ((al (<span style="color: #00af00;">or</span> (<span style="color: #00af00;">and</span> s (cons s1 s))
                (list s1))))
    (apply 'append
           (cl-mapcar (<span style="color: #00af00;">lambda</span> (x)
                        (animate-initialize
                         (car x) (cadr x) (caddr x)))
                      al))))


(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">animate-initn</span> (sn vpos hpos)
  (<span style="color: #00af00;">let</span> ((lsn (split-string sn <span style="color: #ff1f8b;">"\n"</span>)))
    (apply 'animate-init*
           (seq-map-indexed
            (<span style="color: #00af00;">lambda</span> (el id) (list el (+ id vpos) hpos))
            lsn))))

(<span style="color: #00af00;">cl-defun</span> <span style="color: #ef2929;">animate-chars</span> (chars)
  (<span style="color: #00af00;">let</span> ((show-trailing-whitespace nil)
        (indent-tabs-mode nil))
    (<span style="color: #00af00;">dotimes</span> (i animate-n-steps)
      (<span style="color: #00af00;">let</span> (buffer-undo-list
            list-to-undo)
        (animate-step chars (/ i 1.0 animate-n-steps))
        (set-window-start nil 1)
        (sit-for animate-dtime)
        (<span style="color: #00af00;">setq</span> list-to-undo buffer-undo-list)
        (<span style="color: #00af00;">while</span> list-to-undo
          (<span style="color: #00af00;">let</span> ((undo-in-progress t))
            (<span style="color: #00af00;">setq</span> list-to-undo (primitive-undo 1 list-to-undo))))))
    (animate-step chars 1)
    (end-of-line)
    (sit-for 0)
    (undo-boundary)))

(<span style="color: #00af00;">cl-defun</span> <span style="color: #ef2929;">animate-str*</span> (s <span style="color: #18b2b2;">&amp;optional</span> vpos hpos)
  (switch-to-buffer (get-buffer-create
                     (<span style="color: #00af00;">or</span> animation-buffer-name
                         <span style="color: #ff1f8b;">"*Animation*"</span>)))
  (erase-buffer)
  (sit-for 0)
  (animate-chars
   (apply 'animate-init*
          (mapcar (<span style="color: #00af00;">lambda</span> (x) (list (car x)
                                    (+ (cadr x) (<span style="color: #00af00;">or</span> vpos 0))
                                    (+ (caddr x) (<span style="color: #00af00;">or</span> hpos 0))))
                  s))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">animate-strn</span> (str vpos <span style="color: #18b2b2;">&amp;optional</span> hpos)
  (switch-to-buffer (get-buffer-create
                     (<span style="color: #00af00;">or</span> animation-buffer-name
                         <span style="color: #ff1f8b;">"*Animation*"</span>)))
  (erase-buffer)
  (sit-for 0)
  (animate-chars
   (animate-initn str vpos (<span style="color: #00af00;">or</span> hpos 0))))
</pre>
</div>

<p>
使用这些函数可以更加容易地画出上面的《静夜思》和 bug 鱼：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(animate-strn
 <span style="color: #ff1f8b;">"[bug]     /\"*._         _</span>
<span style="color: #ff1f8b;">      .-*'`    `</span><span style="color: #1f5bff;">*-.._.-</span><span style="color: #ff1f8b;">'/</span>
<span style="color: #ff1f8b;">    &lt; * ))     ,       (</span>
<span style="color: #ff1f8b;">      `*-._`._(__.--*\"`.\\"</span>
 15 20)

(animate-str*
 '((<span style="color: #ff1f8b;">"&#38745;&#22812;&#24605;"</span> 1 5)
   (<span style="color: #ff1f8b;">"&#26446;&#30333;"</span> 2 7)
   (<span style="color: #ff1f8b;">"&#24202;&#21069;&#26126;&#26376;&#20809;"</span> 3 3)
   (<span style="color: #ff1f8b;">"&#30097;&#26159;&#22320;&#19978;&#38684;"</span> 4 3)
   (<span style="color: #ff1f8b;">"&#20030;&#22836;&#26395;&#26126;&#26376;"</span> 5 3)
   (<span style="color: #ff1f8b;">"&#20302;&#22836;&#24605;&#25925;&#20065;"</span> 6 3))
15 20)
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-orge397a7b" class="outline-2">
<h2 id="orge397a7b"><span class="section-number-2">3</span> 使用 emacs 的 buffer 显示字符流</h2>
<div class="outline-text-2" id="text-3">
<p>
在上面的 animate 一节中，我简单介绍了动画，对库中的函数实现做了一些解读，并对这个库做了一些简单但有趣的扩展。但是，光凭这个简单的库是实现不了比较复杂的动画效果的，毕竟它只能将字符串随机打散并按照直线运动复原。
</p>

<p>
在这一节中我会尝试让 emacs 接受文本输入并通过通过不断地刷新 buffer 中的内容来达到动画的效果，顺便看看它的最大帧率能到达多少。要实现这个效果，就需要从 buffer 或文件中不断读入字符串，并将字符串打印到正在显示的 buffer 中，只要每两帧之间的时间间隔大于 emacs 的处理时间，即可体现出动画效果。在我的电脑上，让 emacs 处于全屏状态并调用如下函数：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(window-width) =&gt; 191
(window-height) =&gt; 46
</pre>
</div>

<p>
根据调用结果可知，我的 emacs 在当前电脑上支持的最大分辨率是 191 * 46 = 8786。不过按照每格宽高比为 1:2 来算，也就是 90 : 46 而已。接下来的实验过程我会使用 4:3 的比率，也就是 60 : 45 来作为我的屏幕。
</p>
</div>


<div id="outline-container-orgea61939" class="outline-3">
<h3 id="orgea61939"><span class="section-number-3">3.1</span> 如何将视频转为文本</h3>
<div class="outline-text-3" id="text-3-1">
<p>
首先，我们要获取一个视频，这里我使用的是 bilibili 上的 bad apple<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>。首先将它下载下来得到 mp4 格式的视频，随后使用 ffmpeg 对其进行切片，由于原视频帧率为 30 fps，使用以下指令<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>可以获取一张一张的 png 格式图片：
</p>

<div class="org-src-container">
<pre class="src src-bash">ffmpeg -i 1.mp4 -r 30 -f image2 imgs/%d.png
</pre>
</div>

<p>
上面的命令的作用是将 1.mp4 按照每秒 30 张的速度“截图”，然后顺序输出到 img 文件夹中（需要在使用命令前先创建该文件夹）。 <code>-r</code> 选项的作用就是指定每秒“截图”次数。这样一来我们就得到了从 1.png 到 6574.png 的 6574 张图片。
</p>

<p>
得到了图片后，接下来要做的就是将图片转化为 emacs 可以读入的文本文件，为了避免小文件影响 io 效率，这里我选择将所有图片转化得到的文本合并到一个大 txt 文件中。参考这篇文章<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>我们可以很容易地得到解决方案，不过为了连贯性这里还是解释一下如何实现。
</p>

<p>
首先要进行的是图片文件的读取，这项工作可以由 python 的 pillow 库来完成，它提供了丰富的图像处理功能，不过我们只需要用一小部分就行了。要使用这个库的图像处理功能的话，首先要在源文件头部加上 <code>from PIL import Image</code> ，我们要使用它的 Image 类。使用 Image.open 即可得到一个图片对象。
</p>

<p>
接着，由于上面提到的原因，即我的 emacs 最大只支持到 120 * 45 的分辨率，所以我们需要对图像进行缩放得到新的图片，以便提取其中的像素灰度信息。使用 resize 方法可以将图片缩放到所需的宽度和高度。
</p>

<p>
接下来就是像素 RGB 值的获取了，这个可以通过 getpixel 方法获得，它接受坐标元组并返回 <code>(r, g, b)</code> 元组。获取像素后可以通过公式<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>获取该像素的灰度值（对于 bad apple 这种黑白动画其实都无所谓的&#x2026;&#x2026;）。计算公式为：
</p>

<p>
\( Y = 0.299R + 0.587G + 0.114B \)
</p>

<p>
获得灰度值后，我们可以通过比对来得到和它最近的字符。每个字符打印出来的效果是不同的，比如 '$' 和 '.' 就具有不同的灰度。下面我是用的近似字符组，可以看到从左到右单个字符块中的空白越来越多：
</p>

<p>
<code>"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</code>
</p>

<p>
用灰度除以 255 后，再用得到的数值乘以上面灰度字符串的长度即可得到近似的字符对应的索引值，就可以获取近似字符了。
</p>

<p>
最后就是将获取的字符输入到一个字符串中，每处理完一行字符就输出一个换行符，如此往复直到处理完所有图片即可。
</p>

<p>
实现代码如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00af00;">import</span> os
<span style="color: #00af00;">from</span> PIL <span style="color: #00af00;">import</span> Image

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#33719;&#21462;&#28784;&#24230;&#23545;&#24212;&#23383;&#31526;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ff8700;">color_str</span> = <span style="color: #ff1f8b;">"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</span>
<span style="color: #ff8700;">ascii_char</span> = <span style="color: #b218b2;">list</span>(color_str)
<span style="color: #ff8700;">ascii_len</span> = <span style="color: #b218b2;">len</span>(ascii_char)

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">ffmpeg &#36716;&#25442;&#24471;&#21040;&#30340;&#22270;&#29255;</span>
<span style="color: #ff8700;">png_dir</span> = <span style="color: #ff1f8b;">'img'</span>
<span style="color: #ff8700;">my_png</span> = os.listdir(png_dir)
<span style="color: #ff8700;">png_cnt</span> = <span style="color: #b218b2;">len</span>(my_png)

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#22270;&#29255;&#30340;&#23610;&#23544;</span>
<span style="color: #ff8700;">my_width</span> = 120
<span style="color: #ff8700;">my_height</span> = 45

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#25991;&#20214;&#23383;&#31526;&#20018;</span>
<span style="color: #ff8700;">my_str</span> = <span style="color: #ff1f8b;">''</span>

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#25171;&#24320;&#19968;&#20010;&#25991;&#20214;&#65292;&#20197;&#20379;&#36755;&#20986;</span>
<span style="color: #ff8700;">f</span> = <span style="color: #b218b2;">open</span>(<span style="color: #ff1f8b;">'1.txt'</span>, <span style="color: #ff1f8b;">'w'</span>)

<span style="color: #00af00;">for</span> k <span style="color: #00af00;">in</span> <span style="color: #b218b2;">range</span>(1, png_cnt + 1):
    <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#25353;&#20174; 1 &#21040; 6574 &#30340;&#39034;&#24207;&#25171;&#24320;&#25991;&#20214;&#24182;&#22788;&#29702;</span>
    <span style="color: #ff8700;">img</span> = Image.<span style="color: #b218b2;">open</span>(png_dir + <span style="color: #ff1f8b;">'\\'</span> + <span style="color: #b218b2;">str</span>(k) + <span style="color: #ff1f8b;">'.png'</span>)
    <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#32553;&#25918;&#22270;&#29255;&#21040; 120 * 45</span>
    <span style="color: #ff8700;">new_img</span> = img.resize((my_width, my_height), Image.ANTIALIAS)
    <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#26174;&#31034;&#24403;&#21069;&#22788;&#29702;&#22270;&#29255;&#30340;&#24207;&#21495;&#65292;&#21363;&#26174;&#31034;&#36827;&#24230;</span>
    <span style="color: #00af00;">print</span> (k)
    <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#20108;&#23618;&#24490;&#29615;&#22788;&#29702;&#22270;&#29255;</span>
    <span style="color: #00af00;">for</span> i <span style="color: #00af00;">in</span> <span style="color: #b218b2;">range</span>(my_height):
        <span style="color: #00af00;">for</span> j <span style="color: #00af00;">in</span> <span style="color: #b218b2;">range</span>(my_width):
            <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#33719;&#21462; rgb &#20540;</span>
            <span style="color: #ff8700;">r</span>, <span style="color: #ff8700;">g</span>, <span style="color: #ff8700;">b</span> = new_img.getpixel((j, i))
            <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#20844;&#24335;&#35745;&#31639;&#24471;&#21040;&#28784;&#24230;</span>
            <span style="color: #ff8700;">gray</span> = 0.299 * r + 0.587 * g + 0.114 * b
            <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#33719;&#21462;&#23545;&#24212;&#30340;&#36817;&#20284;&#23383;&#31526;</span>
            <span style="color: #ff8700;">unit</span> = 256 / ascii_len
            <span style="color: #ff8700;">my_str</span> += ascii_char[<span style="color: #b218b2;">int</span>(gray / unit)]
        <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#23436;&#25104;&#19968;&#34892;&#20687;&#32032;&#22788;&#29702;&#65292;&#25442;&#34892;</span>
        <span style="color: #ff8700;">my_str</span> += <span style="color: #ff1f8b;">'\n'</span>
    <span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#23383;&#31526;&#20018;&#36798;&#21040;&#19968;&#23450;&#38271;&#24230;&#21518;&#36755;&#20986;&#24182;&#28165;&#38500;&#23383;&#31526;&#20018;&#65292;&#36991;&#20813;&#23383;&#31526;&#20018;&#36807;&#22823;&#24433;&#21709;&#25928;&#29575;</span>
    <span style="color: #00af00;">if</span> k % 200 == 0:
        <span style="color: #00af00;">print</span>(my_str, <span style="color: #b218b2;">file</span>=f, end=<span style="color: #ff1f8b;">''</span>)
        <span style="color: #ff8700;">my_str</span> = <span style="color: #ff1f8b;">''</span>

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#26368;&#21518;&#30340;&#19968;&#27425;&#36755;&#20986;</span>
<span style="color: #00af00;">print</span>(my_str, <span style="color: #b218b2;">file</span>=f)

<span style="color: #b2b2b2; font-style: italic;"># </span><span style="color: #b2b2b2; font-style: italic;">&#20851;&#38381;&#25991;&#20214;</span>
f.close()
</pre>
</div>

<p>
关于上面的代码，这里做一些补充解释，上面获取 unit 值时使用的是 256 而不是 255，这是因为使用 255 后，若 gray 的值为 255，那么最后访问 ascii_char 的序号就是该列表的长度，这样超出了合法访问范围，给 255 加上 1 对最后结果无太大影响。
</p>

<p>
另外需要说的是循环中途的文件写操作，即 k 为 200 倍数时进行的 print 操作。这是为了避免 my_str 随读取文件数量增多而持续增大，这样会导致不断地产生巨大的字符串对象，会严重影响程序执行的速度，所以需要在字符串过大之前将其输出并丢弃，再接受新的字符。
</p>
</div>
</div>


<div id="outline-container-org8d4e796" class="outline-3">
<h3 id="org8d4e796"><span class="section-number-3">3.2</span> 如何在 emacs 中“播放”文本</h3>
<div class="outline-text-3" id="text-3-2">
<p>
实际上到了这里要做的工作基本上已经做完了，只剩下播放字符串这一任务了。在 buffer 中显示不断变化的字符画的实现有多种方式，我想到的是在输出后擦除所有字符后再次输入，不过这样会导致非常明显的屏幕闪烁，非常影响观感。参考<a href="https://github.com/y-usuzumi/emacs-bad-apple/blob/master/badapple.el">这个 github 项目</a>，我发现只需要不断向下翻页就可以实现平滑的动画了，非要说的话记事本也可以做到，但是无法通过编程来实现整数倍的翻页。以下是实现代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">let</span> ((z 1))
  (switch-to-buffer <span style="color: #ff1f8b;">"1.txt"</span>)
  (sit-for 0)
  (<span style="color: #00af00;">while</span> t
    (<span style="color: #00af00;">cl-incf</span> z)
    (goto-line (* z 45))
    (sit-for 0)))
</pre>
</div>

<p>
在对上面代码进行求值之前，你需要在 emacs 中打开 1.txt，注意要使用只读方式打开，否则 emacs 会变得非常卡。对上面代码求值即可看到字符画版的 bad apple 了，你可以调整最后一个 <code>sit-for</code> 的参数值来指定每一张画之间的时间间隔，单位是秒。我上面给的 0 的意思是两帧之间没有间隔时间，但是由于 emacs 运行效率限制，最大也只能达到某个帧数。
</p>
</div>
</div>


<div id="outline-container-org9cd6e82" class="outline-3">
<h3 id="org9cd6e82"><span class="section-number-3">3.3</span> 一个五年前的 bad apple on emacs</h3>
<div class="outline-text-3" id="text-3-3">
<p>
上面代码最终得到的动画我上传到了 bilibili，也就是<a href="https://www.bilibili.com/video/BV1Br4y117S9/">这里</a>，感兴趣的同学可以看一看。另外，上面给的那个 github 项目早在 2016 年就有了，而且还有<a href="https://www.bilibili.com/video/av2393380/">演示视频</a>（不过他的项目里面没有具体介绍视频得到字符本文的方法，我这也不算白做了一遍XD）。
</p>

<p>
通过比较他的视频和我的视频，可以明显的发现他的更加平整一些，而且 bgm 和动画是对的上的。通过在终端中重新测试，我发现终端的性能要明显好于图形界面，使用终端播放完所有的字符只用了 1 分 38 秒，而我的视频时长为 3 分 14 秒，字符界面用时差不多是图形界面的一半。在 Linux 下应该会比同等硬件条件下的 Windows 更快。
</p>

<p>
此外，还可以发现的问题是，开头部分的行数增加速度要明显快于最后的行数增加速度，也许可以考虑将大文件分隔为多个小文件后逐次播放。
</p>
</div>
</div>


<div id="outline-container-orge7a0929" class="outline-3">
<h3 id="orge7a0929"><span class="section-number-3">3.4</span> 总结</h3>
<div class="outline-text-3" id="text-3-4">
<p>
根据实际的动画效果，可以考虑在下面几个方向上做做改进：
</p>

<ol class="org-ol">
<li>将大文件切割为多个小文件来提高 goto-line 的效率，不过该函数是否与文件大小有关目前尚不清楚</li>
<li>使用命令行界面而不是图形界面了播放“动画”</li>
</ol>

<p>
上面的 github 项目中的动画实现使用的是如下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(sit-for 1 840)
(<span style="color: #00af00;">setq</span> z 1442)
(<span style="color: #00af00;">setq</span> tt (run-at-time 0.033 0.03333
                      (<span style="color: #00af00;">lambda</span> ()
                        (<span style="color: #00af00;">setq</span> z (+ z 31))
                        (goto-line z))))
</pre>
</div>

<p>
他使用的是 run-at-time 来按一定时间间隔向下翻动 buffer，我使用 sit-for 来控制时间间隔。至于哪种方法更好还需要进一步的研究。
</p>

<p>
上面列出的一些问题等到我有时间的时候再去想想，毕竟最主要的工作已经完成了 —— 播放 bad apple。
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara"><a href="https://xkcd.com/378/">https://xkcd.com/378/</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Animation">https://en.wikipedia.org/wiki/Animation</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Anime">https://en.wikipedia.org/wiki/Anime</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara"><a href="https://www.bilibili.com/video/BV1xx411c79H">https://www.bilibili.com/video/BV1xx411c79H</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara"><a href="https://www.ffmpeg.org/ffmpeg.html#Video-and-Audio-file-format-conversion">https://www.ffmpeg.org/ffmpeg.html#Video-and-Audio-file-format-conversion</a></p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara"><a href="https://zhuanlan.zhihu.com/p/245651042">https://zhuanlan.zhihu.com/p/245651042</a></p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara"><a href="https://www.dynamsoft.com/blog/insights/image-processing/image-processing-101-color-space-conversion/">https://www.dynamsoft.com/blog/insights/image-processing/image-processing-101-color-space-conversion/</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr class="Solid">
<p>Create Date: 2021-10-23 Sat 22:44</p> <p>Last modified: 2021-10-25 Mon 20:54</p>
<p>Creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>

<p style="text-align:center;">
  <a href="https://beian.miit.gov.cn/">京ICP备2021021729号</a>
</p>

<p style="text-align:center;">
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
  </a><br />
  本作品采用
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    知识共享署名 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
</body>
</html>
