<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-06-26 Sun 16:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>关于 backquote 理解的一个汇总与总结 @@html:&lt;div class="yyheadimg"&gt;&lt;img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzk1OTQ4OTQ=.jpg" alt="load failed"&gt;&lt;/div&gt;@@</title>
<meta name="author" content="include-yy" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../../css/style_gongzhitaao.css" />
<link rel="icon" type="image/x-icon" href="../../img/kagamine_rin.ico">
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="http://www.incf19.com"> HOME </a>
</div><div id="preamble" class="status">
<div>
  <a href="http://www.incf19.com/index.html">Go Home </a>
  <hr class="Solid">
</div>
</div>
<div id="content" class="content">
<h1 class="title">关于 backquote 理解的一个汇总与总结 <div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzk1OTQ4OTQ=.jpg" alt="load failed"></div></h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org193735a">1. 什么是 backquote <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-23 Wed 21:43&gt;</span></span></a></li>
<li><a href="#org35750d6">2. CL 标准中对于 backquote 的描述 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-25 Fri 10:43&gt;</span></span></a></li>
<li><a href="#org7633b4a">3. 怎么理解嵌套的 backquote <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-27 Sun 22:45&gt;</span></span></a></li>
<li><a href="#orgfb725b1">4. 几种常见的嵌套 backquote 组合 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-13 Sun 12:10&gt;</span></span></a>
<ul>
<li><a href="#orgeeea7ee">4.1. ① <code>,,</code></a></li>
<li><a href="#org2b3245c">4.2. ② <code>,',</code></a></li>
<li><a href="#org2a8b414">4.3. ③ <code>,@,</code> 和 <code>,@',</code></a></li>
<li><a href="#org3756bcc">4.4. ④ <code>,,@</code> 和 <code>,',@</code> <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-14 Mon 16:58&gt;</span></span></a></li>
<li><a href="#org00005fc">4.5. ⑤ <code>,@,@</code> 和 <code>,@',@</code></a></li>
<li><a href="#org13e6bcb">4.6. CL 中 backquote 的一个极简实现</a></li>
</ul>
</li>
<li><a href="#org1fd6521">5. elisp 中的 backquote 实现 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-14 Mon 22:52&gt;</span></span></a></li>
<li><a href="#org43b7a94">6. 尾声</a></li>
</ul>
</div>
</div>
<p>
我于今年的 2 月 22 日开始在 emacs-china 上写这篇文章<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>，并在 3 月 14 日完成。不幸地是，2022年 6 月 20 日 emacs-china 因为一些原因暂时闭站了，随后在今天（也就是 26 日）重新恢复。（顺带一提，adnmb 在 20 日重新以 nmbxd 浮起来了）。
</p>

<p>
将近一周的时间没有 emacs-china 可逛让我感觉浑身难受，不过这同时也提醒我自己写的东西要保存好，只有在自己硬盘里面的东西才真正是自己的，本文完成后我没有保存源文档，我还有点担心它会随着闭站直接消失掉（笑）。adnmb 中的许多精华帖子在新岛中也找不到了，听说之后会逐步恢复。看来要想留下点自己记得住的东西还得自己动手，唉。好了，闲话少说，以下是正文部分。
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-22 Tue 22:27&gt;</span></span>
</p>

<p>
今天读了读 emacs 中 generalized variable 的实现方法，gv.el 的代码中用到一些了宏生成宏的技巧，我想着要不要做个关于嵌套 backquote 的总结。
</p>

<p>
本文使用的代码环境如下：
</p>

<ul class="org-ul">
<li>emacs 27.2 x86_64 on windows</li>
<li>ecl 21.2</li>
<li>sbcl 2.0.0</li>
<li>racket 8.2</li>
</ul>

<p>
本文中会使用两种 common lisp 实现，它们分别是 embedded common lisp 和 steel bank common lisp。在需要对不同实现做区分时我会在代码块中以注释说明使用的是哪一种。
</p>

<div id="outline-container-org193735a" class="outline-2">
<h2 id="org193735a"><span class="section-number-2">1.</span> 什么是 backquote <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-23 Wed 21:43&gt;</span></span></h2>
<div class="outline-text-2" id="text-1">
<p>
首先我们从认识什么是 <code>`</code> 开始。在不同的 Lisp 中它不一定是同一个东西。
</p>

<p>
在 elisp 中它是 backquote 宏的别名，它的实现位于 backquote.el 中。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(macrop (symbol-function '\`)) =&gt; t
(eq (symbol-function '\`) (symbol-function 'backquote)) =&gt; t
</pre>
</div>

<p>
在 Scheme 中它是 <code>quasiquote</code> 的缩写，它是一个 <i>special form</i> ：<a href="https://docs.racket-lang.org/reference/quasiquote.html">racket quasiquoting</a>。
</p>

<p>
在 CL 中它是个 <i>macro character</i> （宏字符），与之关联的 <i>reader macro</i> （读取宏）在读到类似 <code>`(a1 a2 ...)</code> 的表达式时 CL 会将其转换为类似 <code>(backquote (a1 a2 ...))</code> 的形式。
</p>

<p>
下面是我在 ECL 中得到的结果：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">ECL</span>

CL-USER&gt; (read)
`(+ 1 2)
(SI:QUASIQUOTE (+ 1 2))

CL-USER&gt; (read)
`(+ 1 `(+ 2 ,(+ ,(+ 1 2) 4)))
(SI:QUASIQUOTE
 (+ 1 (SI:QUASIQUOTE (+ 2 (SI:UNQUOTE (+ (SI:UNQUOTE (+ 1 2)) 4))))))

CL-USER&gt; (read)
`(+ ,@(list 2 3))
(SI:QUASIQUOTE (+ (SI:UNQUOTE-SPLICE (LIST 2 3))))

CL-USER&gt; '`(+ ,.(list 2 3))
(SI:QUASIQUOTE (+ (SI:UNQUOTE-NSPLICE (LIST 2 3))))

CL-USER&gt; (symbol-function 'si:quasiquote)
(SI:MACRO . #&lt;compiled-function SI:QUASIQUOTE 0x244bd00&gt;)
</pre>
</div>

<p>
在 SBCL 中 <code>`</code> 读取后输出的还是它本身，无法直接看到 backquote 宏的名字，需要将 <b>print-pretty</b> 设置为 nil 才行 <a href="https://40ants.com/lisp-hug/2017/14421.html">Quasiquote and Comma symbols</a>。
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
<span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">prompt is `</span><span style="color: #1f5bff; font-style: italic;">\*</span><span style="color: #b2b2b2; font-style: italic;">'</span>
\* (read)
`(+ 1 ,2)
`(+ 1 ,2)

\* (read)
`(+ 1 `(+ 2 ,(+ ,(+ 1 2) 4)))
`(+ 1 `(+ 2 ,(+ ,(+ 1 2) 4)))

\* (setq *print-pretty* nil)

\* '`(+ 1 ,(+ 2 3) ,@(list 4 5))
(SB-INT:QUASIQUOTE
   (+ 1 #S(SB-IMPL::COMMA <span style="color: #b218b2;">:EXPR</span> (+ 2 3) <span style="color: #b218b2;">:KIND</span> 0)
        #S(SB-IMPL::COMMA <span style="color: #b218b2;">:EXPR</span> (LIST 4 5) <span style="color: #b218b2;">:KIND</span> 2)))

\* '`(+ 1 ,.(list 2 3))
(SB-INT:QUASIQUOTE (+ 1 #S(SB-IMPL::COMMA <span style="color: #b218b2;">:EXPR</span> (LIST 2 3) <span style="color: #b218b2;">:KIND</span> 1)))
</pre>
</div>

<p>
不同的 CL 实现中 backquote 的名字不一致， ECL 中 <code>backquote</code> <code>unquote</code> 和 <code>unquote-splicing</code> 分别对应 <code>SI:QUASIQUOTE</code> ， <code>SI:UNQUOTE</code> 和 <code>SI:UNQUOTE-SPLICE</code> 。而 SBCL 中分别是 <code>SB-INT:QUASIQUOTE</code> ， <code>#S(SB-IMPL:COMMA :EXPR expr :KIND 0)</code> 和 <code>#S(SB-IMPL:COMMA :EXPR expr :KIND 2)</code> 。
</p>

<p>
总之，在 CL 中， <code>`</code> 表达式会被内部的 <code>backquote</code> 宏处理得到我们想要的结果，至于内部实现其实并不需要怎么关心。
</p>
</div>
</div>

<div id="outline-container-org35750d6" class="outline-2">
<h2 id="org35750d6"><span class="section-number-2">2.</span> CL 标准中对于 backquote 的描述 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-25 Fri 10:43&gt;</span></span></h2>
<div class="outline-text-2" id="text-2">
<p>
这一节主要是介绍一下 X3J13 在 2.4.6 节中的内容。我们可在 <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">HyperSpec</a> 浏览该文档。
</p>

<p>
根据文档上的说法， <code>backquote</code> 引入了一种用于构建数据结构的模板。使用它可以比较轻松地得到想要的内容，而不必使用各种构造函数。下面的两个表达式可看作等价的（从求值结果上来说），可把后者看作前者的宏展开结果。
</p>

<div class="org-src-container">
<pre class="src src-lisp">`(<span style="color: #00af00;">cond</span> ((numberp ,x) ,@y) (t (print ,x) ,@y))

(list 'cond (cons (list 'numberp x) y)
            (list* 't (list 'print x) y))
</pre>
</div>

<p>
<code>backquote</code> 和 <code>quote</code> 的区别在于前者允许它接受的表达式被部分求值。通过在 <code>`</code> 作用范围内使用 <code>,</code> <code>,@</code> 或 <code>,.</code> 可将紧随的表达式的值插入对应位置。下面是一些简单的例子：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>

\* `(1 2)
(1 2)

\* `(1 ,(+ 2 3))
(1 5)

\* `(1 ,@(list 2 3))
(1 2 3)

\* `(1 ,.(list 2 3))
(1 2 3)
</pre>
</div>

<p>
<code>,</code> 表示求值并插入值， <code>,@</code> 表示求值并将结果“脱皮”（spliced）后再插入。 <code>,.</code> 和 <code>,@</code> 基本一致，不过它允许对由它得到的表结构进行带副作用的操作。下文中我基本上不会用到 <code>,.</code> ，等找到了合适的例子看能不能说一下。
</p>

<p>
下面就是对 <code>backquote</code> 展开规则的介绍了，这里基本上算是把文档翻译了一遍：
</p>

<ol class="org-ol">
<li><p>
对于非表非向量的表达式 <code>basic</code> ， <code>`basic</code> 和 <code>'basic</code> 一样
</p>

<div class="org-src-container">
<pre class="src src-lisp">(equal `a 'a) =&gt; t
</pre>
</div></li>

<li><p>
对于不以 <code>@</code> 或 <code>.</code> 开头的表达式 <code>form1</code> ， <code>`,form1</code> 就是 <code>from1</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">`,(+ 1 2) =&gt; 3
</pre>
</div></li>

<li><p>
<code>`,@form1</code> 的值是未定义的
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">ecl</span>
,@ or ,. has appeared in an illegal position.
<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">sbcl</span>
`,@(LIST 1 2 3) is not a well-formed backquote expression
</pre>
</div></li>

<li><code>`(x1 x2 x3 ... xn . atom)</code> 可展开为 <code>(append [ x1] [ x2] [ x3] ... [ xn] (quote atom))</code></li>

<li><code>`(x1 x2 x3 ... xn)</code> 可展开为 <code>(append [ x1] [ x2] [ x3] ... [ xn] nil)</code></li>

<li><code>`(x1 x2 x3 ... . ,from)</code> 可展开为 <code>(append [ x1] [ x2] [ x3] ... [ xn] form)</code></li>

<li><code>`(x1 x2 x3 ... xn . ,@form)</code> 具有未定义结果</li>

<li><code>`#(x1 x2 x3 ... xn)</code> 可展开为 <code>(apply #'vector `(x1 x2 x3 ... xn))</code></li>
</ol>


<p>
列表形式的 backquote 展开的关键在于对 [ xi] 的处理。
</p>

<ul class="org-ul">
<li>① 若 <code>xi</code> 是 <code>form1</code> 形式，那么 <code>[ xi]</code> 是 <code>(list `form1)</code> ， <b>它还需要进一步的展开</b></li>
<li>② 若 <code>xi</code> 是 <code>,form1</code> 形式，那么 <code>[ xi]</code> 是 <code>(list form1)</code></li>
<li>③ 若 <code>xi</code> 是 <code>,@form1</code> 形式，那么 <code>[ xi]</code> 就是 <code>form1</code></li>
</ul>


<p>
上面的规则解释只是文档中列出的一种，文档也说明了 CL 实现可以自由选择展开方法，只需要保证展开结果与文档标准的求值结果是 <code>equal</code> 的即可。下文中我可能有时会使用 <code>list</code> 或 <code>list*</code> 来替代 <code>append</code> ，让表达式看起来更加简单。
</p>

<p>
下面我们用一些简单的例子来观察一下一次展开得到的结果，这里使用 ECL
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">ECL</span>

CL-USER&gt; (macroexpand '`(1 ,(+ 2 3)))
(LIST 1 (+ 2 3))

CL-USER&gt; (macroexpand '`(1 ,@(list* 1 2 3 '(4)) 5))
(LIST* 1 (APPEND (LIST* 1 2 3 '(4)) '(5)))
</pre>
</div>

<p>
关于 <code>backquote</code> 的嵌套，文档中简单提了句：
</p>

<blockquote>
<p>
If the backquote syntax is nested, the innermost backquoted form should be expanded first. This means that if several commas occur in a row, the leftmost one belongs to the innermost backquote.
</p>
</blockquote>

<p>
简单来说就是，如果存在嵌套的 <code>backquote</code> ， <b>那么最内层的 backquote 应该首先得到展开。</b> 如果多个 <code>,</code> 同时出现，那么最左边的就是最内层的。
</p>

<p>
理解了这句话就理解了嵌套 <code>backquote</code> 的求值方式。不过这一节内容已经够多了，关于它的解释我们留到下一节。下面的内容主要就是围绕规则 ① 和嵌套 <code>backquote</code> 来展开，我可能先从 Scheme（或者 racket）开始讲起，感觉它的更好理解一点。
</p>

<p>
在本节的最后留个例子当作下一节的引子吧。
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (macroexpand '`(apply #'+ 1 ,2 `(3 4 ,(+ 5 6) ,,(+ 7 9))))
(LIST 'APPLY '#'+ 1 2 (LIST 'LIST 3 4 '(+ 5 6) (+ 7 9)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7633b4a" class="outline-2">
<h2 id="org7633b4a"><span class="section-number-2">3.</span> 怎么理解嵌套的 backquote <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-02-27 Sun 22:45&gt;</span></span></h2>
<div class="outline-text-2" id="text-3">
<p>
接下来就是本文最重要的部分了，即对于嵌套 <code>backquote</code> 的理解。由于 Scheme/Racket 中的 <code>quasiquote</code> 更好理解，所以我们先从它开始，这里参考的是 <a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_768">r6rs</a>。关于简单的 backquote/unquote 上面已经举了一些例子了，这里就不说了，下面是 r6rs 关于嵌套 <code>quasiquote</code> 的解释：
</p>

<blockquote>
<p>
Quasiquote forms may be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost quasiquote. The nesting level by one inside each successive quasiquotation, and decreases by one inside each unquotation.
</p>
</blockquote>

<p>
这段话的意思是，对于嵌套的 <code>backquote</code> ，只有和最外层 <code>quasiquote</code> 同层次的 <code>unquote</code> 才会被求值，嵌套层次随 <code>quasiquote</code> 的出现递增，随 <code>unquote</code> 或 <code>unquote-splicing</code> 的出现递减。
</p>

<p>
r6rs 上给出了求值例子：
</p>

<div class="org-src-container">
<pre class="src src-scheme">`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
=&gt; (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
</pre>
</div>

<p>
我们可通过高亮来强调层次。这里为了方便直接用 ppt 绘图：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./1.png" alt="1.png" /></td>
</tr>
</tbody>
</table>

<p>
可见，只有层次为 0 的 <code>unquote</code> 被求值了，它的值被放入的结果表达式中。这其实也就是我在话题开头引用的那个帖子中提到的规则：
</p>

<ol class="org-ol">
<li>嵌套的 <code>quasiquote</code> 一次只展开一层</li>
<li>只替换和最外层同一层次的 <code>unquote</code></li>
<li>每出现一个 <code>`</code> 则层次加一，出现 <code>,</code> 或 <code>,@</code> 则层次减一</li>
</ol>

<p>
这个规则非常简单易懂，但是 X3J13 中关于嵌套宏的描述就不是那么明了了。我们复述一下上个帖子中的内容：
</p>

<ol class="org-ol">
<li>若存在 <code>backquote</code> 嵌套，那么最里面的 <code>backquote</code> 先展开</li>
<li>最靠左的 <code>comma</code> （也就是一系列 <code>unquote</code> ）属于最里层的 <code>backquote</code></li>
</ol>

<p>
该规则的第二条和 r6rs 中的第三条是一个意思，关键在于“最里面的 <code>backquote</code> 先展开”这一规则该如何理解，它和 Scheme 规则有什么关联呢。
</p>

<p>
在具体开始之前，我们先回顾一下规则 ①：
</p>

<ul class="org-ul">
<li>若 xi 是 form1 形式，那么 [ xi] 是 (list `form1) ，它还需要进一步的展开</li>
</ul>

<p>
也就是说， <code>backquote</code> 接受的表中的非 <code>,</code> <code>,@</code> 形式的元素会进行递归式的 <code>backquote</code> 展开。举例来说的话：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>

CL-USER&gt; (macroexpand '`(((,a))))
(LIST (LIST (LIST A)))

(setq a 1)
CL-USER&gt; `(((,a)))
(((1)))


CL-USER&gt; (macroexpand '`(1 (,(+ 2 3)) ((4 5))))
(LIST* 1 (LIST (+ 2 3)) (QUOTE (((4 5)))))

CL-USER&gt; `(1 (,(+ 2 3)) ((4 5)))
(1 (5) ((4 5)))
</pre>
</div>

<p>
CL 实现或多或少采用了自己的方法实现 <code>backquote</code> ，在展开过程中可能简化了一些表达式，所以上面得到的展开结果和标准中的不一致。拿上面的 <code>`(((,a)))</code> 来举例，我们用上一节描述的标准规则进行展开。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(macroexpand '`(((,a))))
=&gt; (append (list `((,a))) nil)
=&gt; (append (list (append (list `(,a)) nil)) nil)
=&gt; (append (list (append (list (append (list a) nil)) nil)) nil)
(setq a 'a)
`(((,a))) =&gt; (((a)))
</pre>
</div>

<p>
根据嵌套 <code>backquote</code> 先展开内部的原则，我们使用下面的例子尝试一下：
</p>

<div class="org-src-container">
<pre class="src src-lisp">``(b ,c)
=&gt; `(append (list 'b) (list c) nil)
=&gt; (append (list `append) (list `(list 'b)) (list `(list c)) (list `nil))
=&gt; (append (list 'append) (list (append (list `list) (list `'b) nil)) (list (append (list 'list) (list `c) nil)) (list 'nil) nil)

(append (list 'append) (list (append (list `list) (list `'b) nil)) (list (append (list 'list) (list `c) nil)) (list 'nil) nil)
=&gt; (append (list 'b) (list c) nil)
(setq b 1 c 2)
(append (list 'b) (list c) nil)
=&gt; (b 2)
</pre>
</div>

<p>
所谓的最内层最先展开就是这样做的，最内层最先展开也就意味着最外层最先求值。这个规则的另一种描述就是 Scheme 规则的第一条和第二条，使用 Scheme 规则显然更利于理解。对 <code>``(b ,c)</code> 的第一次求值得到 <code>`(b ,c)</code> ，对结果再求值就可得 <code>(b 2)</code> 了。
</p>

<p>
这里附上一种 <code>backquote</code> 的实现方法：Appendix C. Backquote<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<p>
关于嵌套 <code>backquote</code> 的原理基本上就讲的差不多了，接下来的内容主要介绍一些嵌套 <code>unquote</code> 的用法。这里先用个例子做引子吧：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
(setq a '((list 1 2) (list 3 4)))
(setq *print-pretty* t)
CL-USER&gt; ``(,@,@a)
`(,@(LIST 1 2) ,@(LIST 3 4))
CL-USER&gt; `(,@(LIST 1 2) ,@(LIST 3 4))
(1 2 3 4)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb725b1" class="outline-2">
<h2 id="orgfb725b1"><span class="section-number-2">4.</span> 几种常见的嵌套 backquote 组合 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-13 Sun 12:10&gt;</span></span></h2>
<div class="outline-text-2" id="text-4">
<p>
要拿排列组合来说的话， <code>,</code> 和 <code>,@</code> 的两两组合只有四种，再加上中间可能出现的 <code>'</code> ，那也就只有八种而已。更多的嵌套只不过是从这几种继续堆叠。所以弄清楚了二重嵌套就差不多弄清了其他更复杂的嵌套。
</p>
</div>

<div id="outline-container-orgeeea7ee" class="outline-3">
<h3 id="orgeeea7ee"><span class="section-number-3">4.1.</span> ① <code>,,</code></h3>
<div class="outline-text-3" id="text-4-1">
<p>
这应该是最容易想到的嵌套方法，两个 <code>,</code> 表示每消掉一层 <code>`</code> 都对 <code>,</code> 作用的表达式求值一次，就像这样：
</p>

<div class="org-src-container">
<pre class="src src-lisp">``(,,(list '+ 1 2))
=&gt; `(,(+ 1 2))
=&gt; (3)
</pre>
</div>

<p>
我对 emacs27 的 elisp 源文件使用了 <code>git grep ,,</code> 搜索，这种用法在宏中好像不多，我好像只在 ert.el 和 radix-tree.el 中看到了这种用法。有兴趣的同学可以去看看。
</p>
</div>
</div>

<div id="outline-container-org2b3245c" class="outline-3">
<h3 id="org2b3245c"><span class="section-number-3">4.2.</span> ② <code>,',</code></h3>
<div class="outline-text-3" id="text-4-2">
<p>
这种用法表示展开外层 <code>`</code> 时对内层求值，在展开内层 <code>`</code> 时对上一次求值结果的 <code>quote</code> 形式求值，从而相当于只在外层展开时求值。
</p>

<div class="org-src-container">
<pre class="src src-lisp">``(,',(list '+ 1 2))
=&gt; `(,'(+ 1 2))
=&gt; ((+ 1 2))
</pre>
</div>

<p>
这种用法可以在 gv.el 中找到，这里我举个简单的例子，假设我们需要定义得到对符号加减乘除的表达式的宏
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">madd</span> (sm num)
  `(<span style="color: #00af00;">setq</span> ,sm (+ ,sm ,num)))
</pre>
</div>

<p>
假设我们想要创建一个创建这种宏的宏，我们可以让宏的名字和操作符作为生成宏的参数：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">m-op</span> (name op)
  `(<span style="color: #00af00;">defmacro</span> ,name (sm arg)
     `(<span style="color: #00af00;">setq</span> ,sm (,',op ,sm ,arg))))

(macroexpand '(m-op abc +))
=&gt; (<span style="color: #00af00;">defalias</span> '<span style="color: #ef2929;">abc</span> (cons 'macro #'(<span style="color: #00af00;">lambda</span> (sm arg) `(<span style="color: #00af00;">setq</span> ,sm (,'+ ,sm ,arg)))))

(<span style="color: #00af00;">setq</span> a 2)
(abc a 2) =&gt; 4
</pre>
</div>
</div>
</div>

<div id="outline-container-org2a8b414" class="outline-3">
<h3 id="org2a8b414"><span class="section-number-3">4.3.</span> ③ <code>,@,</code> 和 <code>,@',</code></h3>
<div class="outline-text-3" id="text-4-3">
<p>
这种用法表示先求值后展平，就像这样：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">``(,@,(list 'list 1 2 3))
=&gt; `(,@(list 1 2 3))
=&gt; (1 2 3)
</pre>
</div>

<p>
至于 <code>,@',</code> ，它和上面的 <code>,',</code> 类似，也相当于只在外层 <code>`</code> 展开时进行一次求值
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">``(,@',(list 'list 1 2 3))
=&gt; `(,@'(list 1 2 3))
=&gt; (list 1 2 3)
</pre>
</div>

<p>
这种用法我在 emacs 代码中貌似搜索不到……
</p>

<p>
上一节的最后我举了一个使用 <code>,@,@</code> 嵌套的例子，它在 elisp 里面是行不通的：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">setq</span> a '((list 1 2) (list 3 4)))
``(,@,@a)
=&gt; `((\,@ (list 1 2) (list 3 4)))
</pre>
</div>

<p>
可见外层的 <code>,@</code> 并未作用到内层展开得到的所有项上，这与 emacs 中的实现有关。
</p>
</div>
</div>

<div id="outline-container-org3756bcc" class="outline-3">
<h3 id="org3756bcc"><span class="section-number-3">4.4.</span> ④ <code>,,@</code> 和 <code>,',@</code> <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-14 Mon 16:58&gt;</span></span></h3>
<div class="outline-text-3" id="text-4-4">
<p>
<code>,,@</code> 表示先展平，后对展平的 <b>各项</b> 求值：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
\* ``(,,@(list '(+ 1 2) '(+ 2 3)))
`(,(+ 1 2) ,(+ 2 3))
\* `(,(+ 1 2) ,(+ 2 3))
(3 5)
</pre>
</div>

<p>
<code>,',@</code> 类似于上面 ③ 中加 <code>'</code> 的情况，但要注意 <code>,@</code> 得到的结果只能有一项，否则就会出错：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
\* ``(,',@(list '(+ 1 2)))
`(,'(+ 1 2))
\* `(,'(+ 1 2))
((+ 1 2))


\* ``(,',@(list '(+ 1 2) '(+ 2 3)))
`(,(QUOTE (+ 1 2) (+ 2 3)))
\* `(,(QUOTE (+ 1 2) (+ 2 3)))

debugger invoked on a SIMPLE-ERROR in thread
#&lt;THREAD <span style="color: #ff1f8b;">"main thread"</span> RUNNING {10010B0523}&gt;:
  wrong number of args to QUOTE:
 (QUOTE (+ 1 2) (+ 2 3))
</pre>
</div>
</div>
</div>

<div id="outline-container-org00005fc" class="outline-3">
<h3 id="org00005fc"><span class="section-number-3">4.5.</span> ⑤ <code>,@,@</code> 和 <code>,@',@</code></h3>
<div class="outline-text-3" id="text-4-5">
<p>
<code>,@,@</code> 表示进行二次展平， <code>,@',@</code> 和 <code>,',@</code> 类似，后一 <code>,@</code> 展开得到的结果只能有一项：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
\* ``(,@,@(list '(list 1 2) '(list 3 4)))
`(,@(LIST 1 2) ,@(LIST 3 4))
\* `(,@(LIST 1 2) ,@(LIST 3 4))
(1 2 3 4)

\* ``(,@',@(list '(list 1 2)))
`(,@'(LIST 1 2))
\* `(,@'(LIST 1 2))
(LIST 1 2)
</pre>
</div>

<p>
对于 ④ 和 ⑤ ，elisp 中都无法得到令人满意的结果，这是由于 elisp 的 <code>backquote</code> 不符合 CL 标准而导致的，在上上节的链接<sup><a id="fnr.2.100" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>中，作者这样说到：
</p>

<blockquote>
<p>
the rules given here work, but some Common Lisp implementations have run into trouble at one time or another by using a simplification rule that does not work in all cases.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">elisp</span>
``(,,@(list '(+ 1 2) '(+ 3 4)))
=&gt; `((\, (+ 1 2) (+ 3 4)))
=&gt; error <span style="color: #ff1f8b;">"Multiple args to , are not supported"</span>

``(,,@(list '(+ 1 2)))
=&gt; `(,(+ 1 2))
=&gt; (3)


``(,@,@(list '(list 1 2) '(list 3 4)))
=&gt; `((\,@ (list 1 2) (list 3 4)))
=&gt; error

``(,@,@(list '(list 1 2)))
=&gt; `(,@(list 1 2))
=&gt; (1 2)
</pre>
</div>

<p>
按照 CL 标准，上面的各表达式展开结果应该是这样的（方便起见，这里就只展开最里层说明一下）
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">``(,,@(list '(+ 1 2) '(+ 3 4)))
`(append (list ,@(list '(+ 1 2) '(+ 3 4))) nil)
(eval it) =&gt; (append (list (+ 1 2) (+ 3 4)) nil)
(eval it) =&gt; (3 7)

``(,@,@(list '(list 1 2) '(list 3 4)))
`(append ,@(list '(list 1 2) '(list 3 4)) nil)
(eval it) =&gt; (append (list 1 2) (list 3 4) nil)
(eval it) =&gt; (1 2 3 4)
</pre>
</div>
</div>
</div>

<div id="outline-container-org13e6bcb" class="outline-3">
<h3 id="org13e6bcb"><span class="section-number-3">4.6.</span> CL 中 backquote 的一个极简实现</h3>
<div class="outline-text-3" id="text-4-6">
<p>
本节剩下的内容是对 CL 实现的一个简单分析，此处的实现参考了<sup><a id="fnr.2.100" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>，出于简单考虑，我没有对展开时进行化简，且没有实现 <code>,.</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">ec$  &#21363; backuqote</span>
<span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">ec%  &#21363; unquote</span>
<span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">ec%@ &#21363; unquote-splicing</span>

(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">ec$</span> (x)
  <span style="color: #cc0000;">"the backquote macro</span>
<span style="color: #cc0000;">ec means emacs-china, bk means backquote"</span>
  (ec-bk-process x))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">ec-bk-process</span> (x)
  (<span style="color: #00af00;">cond</span>
    ((atom x) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#21407;&#23376;&#31867;&#22411;&#30452;&#25509;&#29992; quote</span>
     (list 'quote x))
    ((eq (car x) 'ec$) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23884;&#22871; ` &#22788;&#29702;&#65292;&#21363;&#36882;&#24402;&#22788;&#29702;&#65292;&#20808;&#20174;&#26368;&#37324;&#23618;&#24320;&#22987;</span>
     (ec-bk-process (ec-bk-process (cadr x))))
    ((eq (car x) 'ec%) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#36887;&#21495;&#22788;&#29702;&#65292;&#21363; ,expr</span>
     (cadr x)) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">(unquote expr)</span>
    ((eq (car x) 'ec%@) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">`&#30340;&#21518;&#38754;&#19981;&#24212;&#30452;&#25509;&#20986;&#29616; ,@</span>
     (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">",@~S after `"</span> (cadr x)))
    (t <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#22788;&#29702; `(a1 a2 ... an) &#30340;&#24773;&#20917;</span>
     (<span style="color: #00af00;">do</span> <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#20351;&#29992; ec-bracket &#22788;&#29702;&#34920;&#20013;&#30340;&#27599;&#19968;&#39033;</span>
      ((p x (cdr p))
       (q '() (cons (ec-bracket (car p)) q)))
      ((atom p) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#32467;&#26463;&#26465;&#20214;</span>
       (cons 'append
         (nreconc q (list (list 'quote p)))))
       <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#20013;&#36884;&#26816;&#26597;</span>
       (<span style="color: #00af00;">when</span> (eq (car p) 'ec%) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#36935;&#21040;&#20102;&#33853;&#21333;&#30340; `,'</span>
     <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23427;&#21482;&#33021;&#20197; `(e1 e2 ... . ,e-last) &#30340;&#24418;&#24335;&#20986;&#29616;</span>
     <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#19968;&#33324;&#24773;&#20917;&#19979;&#65292;&#24453;&#22788;&#29702;&#34920;&#30340;&#24418;&#24335;&#26159; ((unquote ...) ...)&#65292;&#21462;&#20854; car &#24471;&#21040;&#30340;&#26159;&#34920;&#32780;&#19981;&#26159;&#31526;&#21495;</span>
     (<span style="color: #00af00;">unless</span> (null (cddr p)) (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"Malformed ,~S"</span> p))
     (<span style="color: #00af00;">return</span> (cons 'append (nreconc q (list (cadr p))))))
       (<span style="color: #00af00;">when</span> (eq (car p) 'ec%@) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#36935;&#21040;&#20102;&#33853;&#21333;&#30340; ,@ &#12290;&#23427;&#19981;&#21487;&#33021;&#21333;&#29420;&#20986;&#29616;</span>
     (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"dotted ,@~S"</span> p))))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">ec-bracket</span> (x)
  (<span style="color: #00af00;">cond</span>
    ((atom x) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#32473;&#21407;&#23376;&#21152;&#19978; quote</span>
     (list 'list (ec-bk-process x)))
    ((eq (car x) 'ec%) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23545; (unquote expr) &#30340;&#22788;&#29702;</span>
     (list 'list (cadr x)))
    ((eq (car x) 'ec%@) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23545; (unquote-splicing expr) &#30340;&#22788;&#29702;</span>
     (cadr x))
    (t <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#20854;&#20182;&#24773;&#20917;&#65292;&#20063;&#23601;&#26159;&#35268;&#21017;&#20013;&#30340;&#8220;&#36827;&#19968;&#27493;&#22788;&#29702;&#8221;</span>
     (list 'list (ec-bk-process x)))))
</pre>
</div>

<p>
我们可以用上面的例子来检验一下正确性，由于没有用 read-macro，所以写起来有点麻烦：
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ec$ (1 (ec% (+ 2 3))))
(1 5)

(ec$ ((ec%@ (list 1 2 3))))
(1 2 3)

(ec$ (ec$ ((ec% (ec% (list '+ 1 2))))))
(APPEND (LIST (+ 1 2)) 'NIL)
(3)

(ec$ (ec$ ((ec% (quote (ec% (list '+ 1 2)))))))
(APPEND (LIST '(+ 1 2)) 'NIL)
((+ 1 2))

(ec$ (ec$ ((ec%@ (ec% (list 'list 1 2 3))))))
(APPEND (LIST 1 2 3) 'NIL)
(1 2 3)

(ec$ (ec$ ((ec%@ (quote (ec% (list 'list 1 2 3)))))))
(APPEND '(LIST 1 2 3) 'NIL)
(LIST 1 2 3)

(ec$ (ec$ ((ec% (ec%@ (list '(+ 1 2) '(+ 2 3)))))))
(APPEND (LIST (+ 1 2) (+ 2 3)) 'NIL)
(3 5)

(ec$ (ec$ ((ec% (quote (ec%@ (list '(+ 1 2))))))))
(APPEND (LIST '(+ 1 2)) 'NIL)
((+ 1 2))

(ec$ (ec$ ((ec%@ (ec%@ (list '(list 1 2) '(list 2 3)))))))
(APPEND (LIST 1 2) (LIST 2 3) 'NIL)
(1 2 2 3)

(ec$ (ec$ ((ec%@ (ec%@ (list '(list 1 2)))))))
(APPEND (LIST 1 2) 'NIL)
(1 2)
</pre>
</div>

<p>
本想着也简化一下 elisp 中的实现贴过来的，不过这一节的内容已经够多了，关于 elisp 我们留到下一节吧。
</p>
</div>
</div>
</div>

<div id="outline-container-org1fd6521" class="outline-2">
<h2 id="org1fd6521"><span class="section-number-2">5.</span> elisp 中的 backquote 实现 <span class="timestamp-wrapper"><span class="timestamp">&lt;2022-03-14 Mon 22:52&gt;</span></span></h2>
<div class="outline-text-2" id="text-5">
<p>
elisp 实现的就是类 Scheme 标准的 <code>backquote</code> ，它不能像 CL 一样处理形如 <code>,,@</code> ， <code>,@,@</code> 的嵌套 <code>unquote</code> 。考虑到 emacs lisp 主要继承于 maclisp，它的 <code>backquote</code> 与 CL 不一致挺正常的。但至于这种 <code>backquote</code> 是否来自 maclisp 我就没有精力进一步考古了。
</p>

<blockquote>
<p>
GNU Emacs Lisp is largely inspired by Maclisp, and a little by Common Lisp. If you know Common Lisp, you will notice many similarities. However, many features of Common Lisp have been omitted or simplified in order to reduce the memory requirements of GNU Emacs.
</p>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-History.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-History.html</a>
</p>
</blockquote>

<p>
在正式开始之前，我们来重新看看 Scheme 和 CL 的两种不同的 <code>backquote</code> 规则：
</p>

<p>
Scheme
</p>

<ol class="org-ol">
<li>嵌套的 <code>quasiquote</code> 一次只展开一层</li>
<li>只替换和最外层同一层次的 <code>unquote</code></li>
<li>每出现一个 <code>`</code> 则层次加一，出现 <code>,</code> 或 <code>,@</code> 则层次减一</li>
</ol>

<p>
CL
</p>

<ol class="org-ol">
<li>若存在 <code>backquote</code> 嵌套，那么最里面的 <code>backquote</code> 先展开</li>
<li>最靠左的 <code>comma</code> （也就是一系列 <code>unquote</code> ）属于最里层的 <code>backquote</code></li>
</ol>

<p>
可见，CL 强调的是内部先于外部展开，而 Scheme 强调的是同层次展开。这两者并不是等价的，Scheme 规则无法像 CL 一样处理类 <code>,,@</code> 嵌套。在 Racket 中我们可以看看 Scheme 的行为，它和 elisp 是一致的：
</p>

<div class="org-src-container">
<pre class="src src-scheme">&gt; ``(,,@(list 1 2))
'`((unquote 1 2))
&gt; `((unquote 1 2))
<span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">stdin:2:2: unquote: expects exactly one expression</span>
<span style="color: #b2b2b2; font-style: italic;">;   </span><span style="color: #b2b2b2; font-style: italic;">at: (unquote 1 2)</span>
<span style="color: #b2b2b2; font-style: italic;">;   </span><span style="color: #b2b2b2; font-style: italic;">in: (quasiquote ((unquote 1 2)))</span>
<span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">[,bt for context]</span>
</pre>
</div>

<p>
扯了这么多废话，现在我们来具体分析一下 elisp 中的实现吧。
</p>

<p>
elisp 实现与 CL 不同，它在递归过程中会记录当前所在层数，当遇到 <code>,</code> 或 <code>,@</code> 时会根据当前层数判断表达式是否被求值。在处理过程中它会对表达式进行分类，它将常量用 0 标识，将非常量用 1 标识，将需要展平的表达式用 2 标识。emacs 实现会对常量表达式进行优化，不考虑优化的话可以简化它的代码。
</p>

<p>
老实说，emacs 中的实现挺难读的，我感觉我不太会讲，下面我贴一下化简后的代码，希望其中的注释对你有所帮助：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">ec$</span> (s) (cdr (bk-process s)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">bk-listify</span> (list tail)
  (<span style="color: #00af00;">let</span> ((heads nil)
    (list-tail list)
    (item nil))
    <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">while &#24490;&#29615;&#32473; list &#20013;&#30340;&#24102;&#26631;&#35782;&#34920;&#36798;&#24335;&#21435;&#26631;&#35782;</span>
    (<span style="color: #00af00;">while</span> (consp list-tail)
      (<span style="color: #00af00;">setq</span> item (car list-tail))
      (<span style="color: #00af00;">setq</span> list-tail (cdr list-tail))
      <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23558; list &#20013;&#30340;&#20869;&#23481;&#25918;&#20837; heads &#20013;</span>
      (<span style="color: #00af00;">setq</span> heads (cons (cdr item) heads)))
    (cons 'cl-list* (append heads (list (cdr tail))))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">bk-delay-process</span> (s level)
  <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23558;&#22836;&#20803;&#32032;&#25343;&#20986;&#26469;&#65292;&#23545;&#34920;&#21097;&#20313;&#37096;&#20998;&#36827;&#34892;&#22788;&#29702;</span>
  (<span style="color: #00af00;">let</span> ((exp (bk-listify (list (cons 0 (list 'quote (car s))))
             (bk-process (cdr s) level))))
    (cons 0 exp)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">bk-process</span> (s <span style="color: #18b2b2;">&amp;optional</span> level)
  (<span style="color: #00af00;">unless</span> level (<span style="color: #00af00;">setq</span> level 0))
  (<span style="color: #00af00;">cond</span>
   ((atom s) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#21407;&#23376;&#30340;&#22788;&#29702;</span>
    (cons 0 (<span style="color: #00af00;">if</span> (<span style="color: #00af00;">or</span> (null s) (eq t s)) s (list 'quote s))))
   ((eq (car s) 'ec%) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">unquote &#30340;&#22788;&#29702;</span>
    (<span style="color: #00af00;">if</span> (&lt;= level 0) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#19982;&#26368;&#22806;&#23618;&#22788;&#20110;&#21516;&#19968;&#23618;&#32423;</span>
    (<span style="color: #00af00;">cond</span>
     ((&gt; (length s) 2) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">(unquote expr) &#38271;&#24230;&#20026; 2&#65292;unquote &#21482;&#33021;&#25509;&#21463;&#19968;&#20010;&#21442;&#25968;</span>
      (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"Multiple args to , are not supported: %S"</span> s))
     (t (cons 1 (nth 1 s))))
      (bk-delay-process s (1- level))))
   ((eq (car s) 'ec%@) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">unquote-splicing &#30340;&#22788;&#29702;</span>
    (<span style="color: #00af00;">if</span> (&lt;= level 0)
    (<span style="color: #00af00;">if</span> (&gt; (length s) 2)
        (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"Multiple args to ,@ are not supported: %S"</span> s)
      (cons 2 (nth 1 s)))
      (bk-delay-process s (1- level))))
   ((eq (car s) 'ec$) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#22810;&#20102;&#19968;&#23618; backquote</span>
    (bk-delay-process s (1+ level)))
   (t <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#21097;&#20313;&#22788;&#29702; `(a1 a2 ... an)</span>
    (<span style="color: #00af00;">let</span> ((rest s) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#34920;&#20013;&#21097;&#19979;&#30340;&#20803;&#32032;</span>
      item <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#27599;&#27425;&#36845;&#20195;&#30340;&#20803;&#32032;</span>
      firstlist <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23384;&#20648;&#22312;&#36935;&#21040; `,@' &#21069;&#30340;&#34920;&#36798;&#24335;</span>
      list <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#26242;&#23384;&#22788;&#29702;&#32467;&#26524;</span>
      lists <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23384;&#20648;&#32467;&#26524;</span>
      expression <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23384;&#20648;&#26368;&#32456;&#32467;&#26524;&#34920;&#36798;&#24335;</span>
      )
      <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#22312;&#24490;&#29615;&#32467;&#26463;&#21518;&#65292; firstlist &#20013;&#23384;&#20648;&#21069;&#37096;&#20998;&#38750; `,@' &#34920;&#36798;&#24335;&#65292; lists &#20013;&#23384;&#20648;&#23637;&#24179;&#34920;&#36798;&#24335;&#65292;list &#20013;&#23384;&#20648;&#21518;&#37096;&#20998;&#38750; `,@' &#34920;&#36798;&#24335;</span>
      (<span style="color: #00af00;">while</span> (<span style="color: #00af00;">and</span> (consp rest)
          (not (<span style="color: #00af00;">or</span> (eq (car rest) 'ec%)
               (eq (car rest) 'ec%@))))
    (<span style="color: #00af00;">setq</span> item (bk-process (car rest) level)) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#33719;&#21462;&#24403;&#21069;&#20803;&#32032;</span>
    (<span style="color: #00af00;">cond</span>
     ((= (car item) 2) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">car &#20026; 2 &#35828;&#26126;&#38656;&#35201;&#23637;&#24179;</span>
      (<span style="color: #00af00;">if</span> (null lists) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#39318;&#27425;&#36935;&#21040; `,@' &#34920;&#36798;&#24335;</span>
          (<span style="color: #00af00;">setq</span> firstlist list <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23558;&#19968;&#20123; `,' &#34920;&#36798;&#24335;&#25918;&#20837; firstlist &#20013;</span>
            list nil)) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#28165;&#31354; list</span>
      (<span style="color: #00af00;">if</span> list <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#33509; list &#38750;&#31354;&#65292;&#23558;&#20854;&#20013;&#30340;&#39033;&#22788;&#29702;&#21518;&#25918;&#20837; lists &#20013;</span>
          <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#36825;&#19968;&#27493;&#25402;&#22937;&#30340;, list &#26159;&#22810;&#20010;&#39033;&#32452;&#25104;&#30340;&#34920;&#65292;&#21040;&#26102;&#20505;&#21644; `,@' &#39033;&#19968;&#36215;&#23637;&#24179;</span>
          (<span style="color: #00af00;">push</span> (bk-listify list '(0 . nil)) lists))
      (<span style="color: #00af00;">push</span> (cdr item) lists) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#23558; splicing &#34920;&#36798;&#24335;&#30340;&#24207;&#21495;&#21435;&#25481;&#21518;&#65292;&#25918;&#20837; lists &#20013;</span>
      (<span style="color: #00af00;">setq</span> list nil))
     (t <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#38750;&#23637;&#24179;&#34920;&#36798;&#24335;&#65292;&#26080;&#38656;&#22788;&#29702;</span>
      (<span style="color: #00af00;">setq</span> list (cons item list)))) <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#32467;&#26524;&#23384;&#20648;&#21040; list &#20013;</span>
    (<span style="color: #00af00;">setq</span> rest (cdr rest)))
      <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23558; list &#20013;&#30340;&#21097;&#20313;&#39033;&#25918;&#20837; lists &#20013;&#21435;</span>
      (<span style="color: #00af00;">if</span> (<span style="color: #00af00;">or</span> rest list)
      (<span style="color: #00af00;">push</span> (bk-listify list (bk-process rest level))
        lists))
      <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">&#33509;&#21482;&#26377;&#19968;&#39033;&#21017;&#21462;&#39318;&#20803;&#32032;</span>
      (<span style="color: #00af00;">setq</span> expression
        (<span style="color: #00af00;">if</span> (<span style="color: #00af00;">or</span> (cdr lists)
            (eq (car-safe (car lists)) 'ec%@))
        (cons 'append (nreverse lists))
          (car lists)))
      <span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">&#23558; firstlist &#20013;&#30340;&#39033;&#22788;&#29702;&#21518;&#25918;&#20837; expression &#20013;</span>
      (<span style="color: #00af00;">if</span> firstlist
      (<span style="color: #00af00;">setq</span> expression (bk-listify firstlist (cons 0 expression))))
      (cons 0 expression)))))
</pre>
</div>

<p>
总之，它没有像 CL 一样从里到外展开，这也就是展开行为与 CL 不一致的原因。
</p>

<p>
这一节主要就是点代码，到了这里本文也就基本结束了。
</p>
</div>
</div>

<div id="outline-container-org43b7a94" class="outline-2">
<h2 id="org43b7a94"><span class="section-number-2">6.</span> 尾声</h2>
<div class="outline-text-2" id="text-6">
<p>
我们以 <code>once-only</code> 这个有名的宏来作为本文的终结吧。看完了上面的内容，相信你一定能看懂这段代码了 :grin:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">CL</span>
(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">once-only</span> (names <span style="color: #18b2b2;">&amp;rest</span> body)
  (<span style="color: #00af00;">let</span> ((gensyms (<span style="color: #00af00;">loop</span> repeat (length names) collect (gensym))))
    `(<span style="color: #00af00;">let</span> (,@(<span style="color: #00af00;">loop</span> for g in gensyms collect `(,g (gensym))))
       `(<span style="color: #00af00;">let</span> (,,@(<span style="color: #00af00;">loop</span> for g in gensyms for n in names
              collect ``(,,g ,,n)))
      ,(<span style="color: #00af00;">let</span> (,@(<span style="color: #00af00;">loop</span> for n in names for g in gensyms
                collect `(,n ,g)))
         ,@body)))))
</pre>
</div>

<p>
下面是 elisp 实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">elisp</span>
(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">with-gensyms</span> (symbols <span style="color: #18b2b2;">&amp;rest</span> body)
  <span style="color: #cc0000;">"Execute BODY in a context where the variables in SYMBOLS are bound to</span>
<span style="color: #cc0000;">fresh gensyms."</span>
  (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (cl-every #'symbolp symbols))
  `(<span style="color: #00af00;">let</span> ,(cl-mapcar #'list symbols '#1=((gensym) . #1#))
     ,@body))

(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">once-only</span> (symbols <span style="color: #18b2b2;">&amp;rest</span> body)
  <span style="color: #cc0000;">"Execute BODY in a context where the values bound to the variables in</span>
<span style="color: #cc0000;">SYMBOLS are bound to fresh gensyms, and the variables in SYMBOLS are bound</span>
<span style="color: #cc0000;">to the corresponding gensym."</span>
  (<span style="color: #00af00;">declare</span> (indent 1))
  (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (cl-every #'symbolp symbols))
  (<span style="color: #00af00;">let</span> ((gensyms (cl-mapcar (<span style="color: #00af00;">lambda</span> (x) (gensym)) symbols)))
    `(with-gensyms ,gensyms
           (list 'let (cl-mapcar #'list (list ,@gensyms) (list ,@symbols))
             ,(cl-list* 'let (cl-mapcar #'list symbols gensyms)
                    body)))))
</pre>
</div>

<p>
最后需要提醒一下的是，不同的 CL 实现中对于 backquote 的处理不一定相同，有些 CL 实现可能与标准并不完全一致：
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">ECL</span>
CL-USER&gt; ``(,@,@(list 1 2 3))
                                        <span style="color: #b2b2b2; font-style: italic;">; Evaluation aborted on #&lt;a SIMPLE-ERROR 0x3d28500&gt;.</span>
,@ or ,. has appeared in an illegal position.
   [Condition of type SIMPLE-ERROR]

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">SBCL</span>
\* ``(,@,@(list 1 2 3))
=&gt; `(,@1 ,@2 ,@3)
</pre>
</div>

<p>
<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzgyNDc3MTU=.png" alt="load failed"></div><div class="yyimgcomment">Lunasa Prismriver</div>
</p>

<p>
<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzY2OTA2NDYy.jpg" alt="load failed"></div><div class="yyimgcomment">Lunasa Prismriver</div>
</p>

<p>
<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzgzODg4NzM2.jpg" alt="load failed"></div><div class="yyimgcomment">Lunasa Prismriver</div>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://emacs-china.org/t/backquote/20060">https://emacs-china.org/t/backquote/20060</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html">https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr class="Solid">
<p>Create Date: 2022-03-14 Mon 22:57</p> <p>Last modified: 2022-06-26 Sun 16:35</p>
<p>Creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.1 (<a href="https://orgmode.org">Org</a> mode 9.5.2)</p>

<p style="text-align:center;">
  <a href="https://beian.miit.gov.cn/">京ICP备2021021729号</a>
</p>

<p style="text-align:center;">
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
  </a><br />
  本作品采用
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    知识共享署名 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
</body>
</html>
