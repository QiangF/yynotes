<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-24 Mon 23:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>emacs 中的哈希表与多值返回 <div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzg0Nzc3OTc2Cg==.jpg" alt="load failed"></div></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="include-yy" />
<link rel="stylesheet" type="text/css" href="../../css/style_gongzhitaao.css" />
<link rel="icon" type="image/x-icon" href="../../img/kagamine_rin.ico">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="http://www.incf19.com"> HOME </a>
</div><div id="preamble" class="status">
<div>
  <a href="http://www.incf19.com/index.html">Go Home </a>
  <hr class="Solid">
</div>
</div>
<div id="content">
<h1 class="title">emacs 中的哈希表与多值返回 <div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzg0Nzc3OTc2Cg==.jpg" alt="load failed"></div></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org950b0ed">1. 数据结构和数据类型</a>
<ul>
<li><a href="#org5771645">1.1. 什么是数据类型</a></li>
<li><a href="#org42555b5">1.2. 抽象数据类型（ADT）</a></li>
<li><a href="#org0e9f281">1.3. 什么是数据结构</a></li>
<li><a href="#org546e3b7">1.4. 数据类型，ADT 和数据结构之间的关系</a></li>
<li><a href="#org757d662">1.5. 示例：一个简单的 ADT 及其实现</a></li>
</ul>
</li>
<li><a href="#orge156bef">2. 什么是哈希表</a>
<ul>
<li><a href="#org56ad1e8">2.1. 作为 ADT 的关联数组</a></li>
<li><a href="#org3fa8ef7">2.2. 哈希函数</a></li>
<li><a href="#org8ea5573">2.3. 哈希碰撞的解决方案</a></li>
</ul>
</li>
<li><a href="#org58a9ea0">3. emacs 的 hashtable</a>
<ul>
<li><a href="#org1acb66d">3.1. hashtable 的创建和表示</a></li>
<li><a href="#org96d4127">3.2. 哈希表属性获取</a></li>
<li><a href="#orgfab7531">3.3. 哈希表的基本操作</a></li>
<li><a href="#org7021176">3.4. 自定义哈希函数</a></li>
</ul>
</li>
<li><a href="#org69707ef">4. emacs 的多值返回</a></li>
<li><a href="#org3b91957">5. 一个简单的哈希表实现</a>
<ul>
<li><a href="#orge37da79">5.1. 哈希函数</a></li>
<li><a href="#org0e841e7">5.2. 哈希表的结构定义</a></li>
<li><a href="#org798bfdb">5.3. 哈希表的查找、删除与遍历</a></li>
<li><a href="#org6725542">5.4. 哈希表的添加</a></li>
<li><a href="#org508281c">5.5. 测试与小结</a></li>
</ul>
</li>
<li><a href="#org64300c6">6. 后记</a></li>
</ul>
</div>
</div>
<p>
本文是对 elisp manual 上 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html">Hash Tables</a> 一章的学习总结。除了介绍哈希表相关函数的使用，本文也会简单介绍哈希表的一些知识。考虑到 elisp 和 common lisp 中哈希函数存在一定的差异，本文也会介绍一下 CL 中的多值返回和 cl-lib 中的对应实现。
</p>

<p>
本文顺带介绍一下数据结构和数据类型的关系。这个问题困扰了我很久，但一直也没有弄清楚的动力。本文的第一章尝试给出一种理解，希望对你有所帮助。
</p>

<p>
本文的最后一节会参考 emacs 的 hashtable 实现来给出一个简单的 elisp 的实现。
</p>

<p>
文中代码使用的环境为：
</p>

<ul class="org-ul">
<li>emacs-27.2-x86_64 on windows</li>
<li>SBCL 2.2.0 on windows</li>
</ul>

<div id="outline-container-org950b0ed" class="outline-2">
<h2 id="org950b0ed"><span class="section-number-2">1</span> 数据结构和数据类型</h2>
<div class="outline-text-2" id="text-1">
<p>
哈希表，它是一种数据类型呢，还是一种数据结构呢？不知你想过这个问题没有。在 Python 中我们有叫做 dict 的 <b>数据类型</b> ，但哈希表（或者叫做散列表）也是一种常见的 <b>数据结构</b> ，而且 Python 的字典类型还是以哈希表 <b>实现</b> 的。数据类型和数据结构的关系我貌似理解的不是很清楚，也许我在学习《数据结构与算法》的时候根本就没想过类似的问题。
</p>

<p>
这个问题我本想留在介绍写完 symbol 类型相关文章后再着重学习一下，但是思来想去发现好像绕不开它，这里就简单的提一下吧。我会参考各方资料来给出我的理解，如有异议欢迎交流。 <b>凡是没有引用的部分都掺杂了我自己的观点。</b>
</p>

<p>
一般来说，提到数据类型时我们可能都会想到编程语言的基本数据类型。在百度上以“数据类型”作为关键字搜索，可以看到一系列某某语言基本类型的内容。说到数据结构，我们想到的大概也是表栈队数图堆等等常见数据结构，以“数据类型”作为关键字，通常会出现“几大数据结构”的搜索结果，或是“数据结构与算法”。以 Google 作为搜索引擎得出的结果大同小异，关注点都在“基本数据类型”和“数据结构与算法”上。
</p>

<p>
想想也明白为什么得到这样的搜索结果。刚开始学习程序语言的时候书的最前几章通常都会介绍一下语言的基本数据类型，毕竟这是语言的基本要素之一。至于数据结构也好理解，常用或者说常见的的也就那几种。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">data type</th>
<th scope="col" class="org-left">data structure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><img src="./1.PNG" alt="1.PNG" /></td>
<td class="org-left"><img src="./2.PNG" alt="2.PNG" /></td>
</tr>

<tr>
<td class="org-left"><img src="./3.PNG" alt="3.PNG" /></td>
<td class="org-left"><img src="./4.PNG" alt="4.PNG" /></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org5771645" class="outline-3">
<h3 id="org5771645"><span class="section-number-3">1.1</span> 什么是数据类型</h3>
<div class="outline-text-3" id="text-1-1">
<p>
关于数据类型，我不是太清楚它是什么时候出现的，这里就抄一下维基百科<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>上的内容吧：
</p>

<blockquote>
<p>
在计算机科学和计算机编程中，数据类型或者类型是指数据的一种属性，它告诉编译器或解释器程序员是如何使用数据的。大多数的程序语言支持基本的数据类型，即整数，浮点数，字符和布尔值。
</p>

<p>
数据类型限制了表达式的取值。数据类型定义了对数据的操作，数据的含义，以及数据的存储值方式。
</p>
</blockquote>

<p>
维基百科上给了尝试给类型一个定义的论文<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>，也许我会找个时间通读一遍，不过现在还是算了吧。上面的引文中强调了数据类型的三个要素，即 <b>变量的操作</b> ， <b>变量的取值</b> 与 <b>变量的存储方式</b> ，其中存储方式是与数据类型的实现相关的。
</p>

<p>
举例来说，C 中的 int 类型使用 4 个字节（大部分）存储，它的取值集合是 -2^32 ~ 2^32 - 1，可以进行的操作包括 +，-，*，/，++，&#x2013;，&lt;，&lt;=，==，!=，&gt;，&gt;=，||，&amp;&amp;，!，&amp;，| 等。这些信息应该足够描述 int 的所有性质了。
</p>
</div>
</div>

<div id="outline-container-org42555b5" class="outline-3">
<h3 id="org42555b5"><span class="section-number-3">1.2</span> 抽象数据类型（ADT）</h3>
<div class="outline-text-3" id="text-1-2">
<p>
同样，这里先贴一点维基百科<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>过来：
</p>

<blockquote>
<p>
在计算机科学中，抽象数据类型是数据类型的数学模型。ADT 是从使用者角度来定义的，它包括所有可能的值，该类型所有可能的操作，以及这些操作的效果。数学模型与数据结构是相对应的，数据结构是数据的具体表示，它是从实现者的角度来定义的。
</p>

<p>
形式上来说，ADT 可以被定义成“逻辑行为（behaviour）由一个取值集合和操作集合定义的某一类对象”，这和数学中的代数结构很类似。对于“逻辑行为”的解释主要有两种，分别是 axiomatic (algebraic) specification（代数规范） 和 abstract model（抽象某型），前者对应于公理语义（<a href="https://en.wikipedia.org/wiki/Axiomatic_semantics">Axiomatic semantics</a>）而后者对应于抽象机器（<a href="https://en.wikipedia.org/wiki/Abstract_machine">Abstract machine</a>）的操作语义（<a href="https://en.wikipedia.org/wiki/Operational_semantics">Operational semantics</a>）。
</p>

<p>
ADT 是一个理论概念，在计算机科学中用于设计和分析算法，数据结构和软件系统。它并不对应于计算机语言中的特性 —— 主流计算机语言不直接支持形式地指定 ADT。但是许多语言的特性都与 ADT 中的某些概念相对应，它们很容易和 ADT 本身相混淆，比如抽象类型，不透明类型，协议和契约式设计（<a href="https://en.wikipedia.org/wiki/Design_by_contract">design by contract</a>）。
</p>
</blockquote>

<p>
上面的一段话主要强调了 ADT 的理论性，相比于数据类型，它只指定了取值集合和操作集合，而没有指定数据类型的具体实现，这应该就是“抽象”代表的意思，即不关心数据类型的具体实现。就我来看，这有点像所谓的“接口与实现分离”，不过这就和各语言提供的抽象机制相关了，不同语言提供了不同的方法来达到该目的。
</p>

<p>
关于 ADT 的定义，维基百科上将它分为两种风格，分别是命令式和函数式，前者强调状态，后者强调无状态（笑）。具体的解释可以自行参考，这里我给一篇左耳朵耗子写的文章，他简单介绍了函数式定义 ADT 的方法：<a href="https://coolshell.cn/articles/10169.html">类型的本质和函数式实现 &#x2013; coolshell</a>
</p>

<p>
在这篇文章里面，他强调 <b>类型的本质是由操作和操作间关系</b> 定义的，使用者 <b>只依赖于类型规范而不依赖于具体实现</b> 。感兴趣的同学可以读一读，我感觉写的非常好。
</p>
</div>
</div>

<div id="outline-container-org0e9f281" class="outline-3">
<h3 id="org0e9f281"><span class="section-number-3">1.3</span> 什么是数据结构</h3>
<div class="outline-text-3" id="text-1-3">
<p>
让我们再次参考维基百科<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>：
</p>

<blockquote>
<p>
在计算机科学中，数据结构是计算机中存储，组织数据的方式。更准确地说，它是数据的代数结构。
</p>

<p>
数据结构是 ADT 的基础。ADT 负责定义数据类型的逻辑形式，数据结构负责实现数据类型的物理形式。不同种类的数据结构适用于不同的应用，某些数据结构是高度特化于特定任务的。例如，关系型数据库一般使用 B 树来索引数据，编译器一般使用哈希表来查符号。
</p>

<p>
数据结构提供了管理大量数据的高效方式。通常，高效的数据结构是实现搞笑算法的关键。某些形式设计方法和程序语言强调数据结构而不是算法来作为软件设计的关键组织因素。
</p>

<p>
数据结构是基于计算机读写任意位置内存数据的能力的。数组和记录（record）数据结构基于数据的地址和（地址）算数操作，链式数据结构基于结构中存储的地址数据。
</p>

<p>
数据结构的实现一般需要编写一个用于创建和操作结构实例的过程集合。数据结构的效率分析是不能脱离这些操作的。
</p>
</blockquote>

<p>
和上面的 ADT 小节结合一下，ADT 和数据结构之间就像是接口与实现的关系。数据结构负责 ADT 的实现，它依赖于计算机提供的内存读写功能。计算机中最基本的存储单元应该就是块状内存了，它应该算得上数据结构之母，或者说随机可随机访问的块状单元是数据结构的基本组成单元。
</p>

<p>
TAOCP 第一卷的第二章介绍的就是各种各样的数据结构，在这一章的开头高德纳这样写道：
</p>

<blockquote>
<p>
计算机程序通常是对一些信息表进行操作。在大多数情况下，这些表不仅仅是杂乱无章的数值集团；它们含有数据元素之间重要的结构关系。
</p>

<p>
在最简单的形式下，一个表可以是元素的一个线性表&#x2026;&#x2026;在更复杂的情况下，表可以是一个二维的数组，或者是具有更高 n 值的 n 维数组；它可以是一个树结构，表示层次或分支关系；或者是复杂的具有大量交互联系的多重链接结构，如同在人的大脑中我们可以找到的那样。为了合理地使用一台计算机，我们需要理解存在于数据内的结构关系，以及在一台计算机内表示和操作这样的结构的基本技术。
</p>

<p>
本章综述关于信息结构最重要的事实；不同类型结构的静态和动态的性质，进行存储分配的手段和结构化数据的表示，以及建立、改变、存取和破坏结构信息的有效算法&#x2026;&#x2026;我们所关心的几乎完全是在一台计算机内部所表示的结构。
</p>
</blockquote>

<p>
对于数据结构的解释可能没有比上面的文字更权威的了。
</p>
</div>
</div>

<div id="outline-container-org546e3b7" class="outline-3">
<h3 id="org546e3b7"><span class="section-number-3">1.4</span> 数据类型，ADT 和数据结构之间的关系</h3>
<div class="outline-text-3" id="text-1-4">
<p>
就我上面提到的内容来看，我可以这样总结一下：数据类型 = ADT + 数据结构。数据类型作为程序实体，ADT 作为理论实体，数据结构负责具体的实现。ADT 和数据结构应该是一对多的关系，即一种接口可以对应不同实现。
</p>

<p>
这一节只能说是一个简单的知识梳理，我挺想找个时间学习一下数据类型对应的计算机发展史的。对于“程序=数据结构+算法”这句话我始终感到不是很理解，它相当于是把数据结构和算法提到了相同重要的程度（可能是理论（算法）和实践（数据结构实现）构成了程序的意思？），也许我对于数据结构的理解和三四十年前的理解有了偏差，这需要一点考古的进行。不过这应该是个超级大坑，希望我能有看“古代”文献的时间。
</p>

<p>
我也听说过类型系统和类型理论，以及神奇的类型体操，希望以后有时间都去了解一下。
</p>

<p>
查资料的时候，不知道咋回事想到了《巴比伦图书馆》这本书，天晓得我为什么想到的（笑）
</p>

<ul class="org-ul">
<li><a href="https://libraryofbabel.info/">https://libraryofbabel.info/</a></li>
<li><a href="https://keiwan.itch.io/library-of-babel-3d">https://keiwan.itch.io/library-of-babel-3d</a></li>
</ul>
</div>
</div>

<div id="outline-container-org757d662" class="outline-3">
<h3 id="org757d662"><span class="section-number-3">1.5</span> 示例：一个简单的 ADT 及其实现</h3>
<div class="outline-text-3" id="text-1-5">
<p>
简单起见，这里我给出一个自然数的 ADT 定义，并使用 LIST 作为其实现。
</p>

<pre class="example">
TYPE NAT:
     Operations:    ;操作
	 zeroy      ;创建 0
	 add1y X    ;将 X 加 1 并返回 X+1
	 sub1y X    ;将 X 减 1 并返回 X-1
     Invariants:    ;约束
	 sub1y(add1y(X)) == X
	 if X is not zero then
	 add1y(sub1y(X)) == X
	 if X is zero then
	 sub1y(X) == zero
</pre>

<p>
这个 ADT 是我随手糊的，严谨性可能得不到保证，下面我们使用 elisp 中的 list （也就是单链表）来实现这个 ADT：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">zeroy</span> () ())
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">add1y</span> (X) (cons '() X))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">sub1y</span> (X) (<span style="color: #00af00;">if</span> (null X) () (cdr X)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">cmpxy</span> (X Y)
  (<span style="color: #00af00;">cond</span> ((<span style="color: #00af00;">and</span> (eq X (zeroy))
              (eq Y (zeroy)))
         0)
        ((eq X (zeroy)) -1)
        ((eq Y (zeroy)) 1)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">addxy</span> (X Y)
  (<span style="color: #00af00;">if</span> (eq X (zeroy))
      Y
    (addxy (sub1y X)
           (add1y Y))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">mulxy</span> (X Y)
  (<span style="color: #00af00;">if</span> (= (cmpxy X (zeroy)) 0) (zeroy)
    (addxy Y (mulxy (sub1y X) Y))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">nat2yyn</span> (n)
  (<span style="color: #00af00;">if</span> (zerop n) (zeroy)
     (add1y (nat2yyn (- n 1)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">facty</span> (X)
  (<span style="color: #00af00;">if</span> (eq X (zeroy)) (add1y (zeroy))
      (mulxy X (facty (sub1y X)))))

(facty (nat2yyn 3)) =&gt; (nil nil nil nil nil nil)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orge156bef" class="outline-2">
<h2 id="orge156bef"><span class="section-number-2">2</span> 什么是哈希表</h2>
<div class="outline-text-2" id="text-2">
<p>
（下大部分内容都来自维基百科中的 hash table 和 hash function 词条，出于美观原因我就不使用引用格式了。考虑到本文的主要内部并不是介绍各种哈希算法，这一节只是简单介绍一些相关知识。）
</p>

<p>
哈希表也叫散列表，它是一种实现了关联数组（associate array）ADT 的数据结构。所谓关联数组就是可将键映射到值的一种结构。哈希表使用哈希函数来计算索引（也叫哈希值），然后使用索引访问数组中的桶或槽，并从中找到想要的数据。
</p>

<p>
理想情况下，哈希函数会将键映射到唯一的桶，但大多数哈希使用了不完美的哈希函数，它会导致多个键的哈希值相同，即出现哈希碰撞。在良好设计的哈希表中，查找的平均时间是独立于表中存储元素个数的。许多哈希表设计允许任意地插入和删除键值对，每次操作只需要常数时间。
</p>

<p>
使用哈希的好处在于值的地址可以通过直接计算键得到。哈希化包括一个哈希函数 h，它应用于键 k 得到哈希值 M。考虑到 M 可能非常的大，哈希值应该映射到有限长度的表中的实体。对于哈希值 M 和长度为 N 的表，通常有几种方式来进行映射。最常见的就是取 N 的余数，即 M % N。
</p>
</div>

<div id="outline-container-org56ad1e8" class="outline-3">
<h3 id="org56ad1e8"><span class="section-number-3">2.1</span> 作为 ADT 的关联数组</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在计算机科学中，关联表也叫做映射（map），符号表（symbol table），或字典（dictionary），它是由键值对组成的 ADT。与之联系的操作包括：
</p>

<ul class="org-ul">
<li>添加一个序对</li>
<li>移除一个序对</li>
<li>修改一个现存序对</li>
<li>查找一个键对应的值</li>
</ul>

<p>
关联数组的两种主流实现是哈希表和查找树。许多语言都将关联数组实现为基本类型，比如 php 中的数组。
</p>
</div>
</div>


<div id="outline-container-org3fa8ef7" class="outline-3">
<h3 id="org3fa8ef7"><span class="section-number-3">2.2</span> 哈希函数</h3>
<div class="outline-text-3" id="text-2-2">
<p>
对哈希函数基本的要求就是提供一个离散均匀分布的值。非离散均匀分布会增加哈希碰撞和处理哈希碰撞的成本。在设计时哈希函数是很难保证均匀的，不过这可以通过统计测试来确认。
</p>

<p>
哈希函数的分布仅需要在表所在范围内是均匀的就行。例如，如果表动态调整大小是精确的加倍或减半的话，那么哈希函数只需要在 2 的幂范围内保证均匀。某些哈希算法更适用于大小为素数的表。
</p>

<p>
如果实现知道了所有的键，那么可以选择完美哈希函数<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>来创建不会冲突的哈希表。
</p>
</div>
</div>


<div id="outline-container-org8ea5573" class="outline-3">
<h3 id="org8ea5573"><span class="section-number-3">2.3</span> 哈希碰撞的解决方案</h3>
<div class="outline-text-3" id="text-2-3">
<p>
最为人所知的两种方法是拉链法和开放寻址法。这方面的文章也挺多了，搜一搜就可以找到，我也懒得自己写一份了，这里就放两个链接吧：
</p>

<ul class="org-ul">
<li><a href="https://www.codeplayer.org/Wiki/Program/CLRS/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B9%8B%E9%93%BE%E6%8E%A5%E6%B3%95.html">散列表之链接法</a></li>

<li><a href="https://www.codeplayer.org/Wiki/Program/CLRS/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B9%8B%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95.html">散列表之开放寻址法</a></li>
</ul>

<p>
文章的作者是 Petrus，这是他的个人博客：<a href="https://www.codeplayer.org/index.html">https://www.codeplayer.org/index.html</a> ，这个 blog 应该是使用了 org-mode 来生成网页。
</p>
</div>
</div>
</div>


<div id="outline-container-org58a9ea0" class="outline-2">
<h2 id="org58a9ea0"><span class="section-number-2">3</span> emacs 的 hashtable</h2>
<div class="outline-text-2" id="text-3">
<p>
本节简单介绍 emacs 中哈希表的使用，简单介绍了各个函数的使用，算是过了一遍官方文档吧。
</p>
</div>

<div id="outline-container-org1acb66d" class="outline-3">
<h3 id="org1acb66d"><span class="section-number-3">3.1</span> hashtable 的创建和表示</h3>
<div class="outline-text-3" id="text-3-1">
<p>
hashtable 是以 record 来表示的，它的 record 类型是 <code>hash-table</code> 。可以通过字面量来创建 hashtable，就像这样：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#s(hash-table size 30 data (a 1 b 300))
=&gt;
#s(hash-table size 30 test eql rehash-size 1.5 rehash-threshold 0.8125 data (a 1 b 300))
</pre>
</div>

<p>
emacs 提供了 <code>make-hash-table</code> 这个函数来创建哈希表，它接受一些关键字来指定 hashtable 的性质。可用的关键字如下：
</p>

<ul class="org-ul">
<li><code>:test</code> 用来指定 hashtable 中的键查找比较方法，默认是 <code>eql</code> ，它可以为 <code>eq</code> <code>eql</code> 和 <code>equal</code></li>

<li><code>:size</code> 用来指定创建哈希表的大小。默认大小是 65</li>

<li><code>:rehash-size</code> ，哈希表满后自动增长时的增长量。如果为整数则必须为正数，它表示在原来基础上加上原大小整数倍数的容量。如果为浮点数则必须大于 1，哈希表在增长时变为原大小乘浮点数。默认值是 1.5</li>

<li><code>:rehash-threshold</code> ，扩容因子，指定哈希表进行自动增长的临界点。当哈希表中的键值对数量与哈希表“标称大小”比值超过该值时哈希表就“满”了。它应该是一个不大于一的浮点数。默认值为 0.8125</li>
</ul>

<p>
所谓的“标称大小”就是实际大小除以扩容因子得到的值，即哈希桶个数，它是大于实际可用存储单元数量的。若 size 取 65，那么哈希桶个数差不多就是 80。这个 0.8125 是有来头的，当表中项数与桶数量之比超过某一界限后，哈希碰撞的几率将直线上升。具体可以词条 hash table<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>上的说明。
</p>

<p>
除了以上四个选项外还有一个 <code>:weakness</code> 选项，它用来指定是否对哈希表中键值对的键或值进行垃圾回收。它的取值为以下几项：
</p>

<ul class="org-ul">
<li><code>key</code> ，哈希表不保护它的键不被 gc。若某一个键被回收了，那么该键值对会从哈希表中移除</li>

<li><code>value</code> ，哈希表不保护它的项中的值不被 gc。若值被回收了，那么该键值对会被移除</li>

<li><code>key-and-value</code> 和 <code>t</code> ，哈希表不保护键和值不被 gc。若某项的键或值被 gc 了，那么该项会被移除</li>

<li><code>key-or-value</code> ，当键和值都被 gc 后，项才会被从哈希表中移除</li>

<li><code>nil</code> ，键值对会被哈希表保护而不被 gc，这是默认选项</li>
</ul>
</div>
</div>

<div id="outline-container-org96d4127" class="outline-3">
<h3 id="org96d4127"><span class="section-number-3">3.2</span> 哈希表属性获取</h3>
<div class="outline-text-3" id="text-3-2">
<p>
以下函数可以获取 hashtable 的各项属性：
</p>

<ul class="org-ul">
<li><code>hash-table-p</code> ，判断对象是否为哈希表</li>

<li><code>hash-table-count</code> ，获取哈希表中键值对个数</li>

<li><code>hash-table-test</code> ，获取 test 函数</li>

<li><code>hash-table-weakness</code> ，用来获取 hashtable 的 weakness 属性</li>

<li><code>hash-table-rehash-size</code> ，获取 rehash-size</li>

<li><code>hash-table-rehash-threshold</code> ，获取 rehash-threshold，即扩容因子</li>

<li><code>hash-table-size</code> ，获取 hashtable 当前大小</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(make-hash-table) =&gt;
#s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data ())

(hash-table-p 1) =&gt; nil
(hash-table-p #s(hash-table)) =&gt; t

(hash-table-count (make-hash-table)) =&gt; 0
(hash-table-test (make-hash-table)) =&gt; eql

(hash-table-weakness (make-hash-table)) =&gt; nil
(hash-table-weakness (make-hash-table <span style="color: #b218b2;">:weakness</span> 'value)) =&gt; value

(hash-table-rehash-size (make-hash-table)) =&gt; 1.5
(hash-table-rehash-threshold (make-hash-table)) =&gt; 0.8125
(hash-table-size (make-hash-table)) =&gt; 65
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfab7531" class="outline-3">
<h3 id="orgfab7531"><span class="section-number-3">3.3</span> 哈希表的基本操作</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><code>gethash key table &amp;optional default</code> ，在表中查找 key，并返回对应的值。若没找到则返回 default</li>

<li><code>puthash key value table</code> ，将键值对加入表中，若键已存在则将值替换为 value</li>

<li><code>remhash key table</code> ，若表中存在 key，从表中删除 key 对应的键值对，否则什么也不做。返回值总为 nil</li>

<li><code>clrhash table</code> ，清空表</li>

<li><code>maphash function table</code> ，对表中键值对使用 function ，返回 nil。函数应接受 key 和 value 两个参数</li>

<li><code>copy-hash-table</code> ，创建并返回一个表的副本，与原表共享键值对，也就是浅拷贝。</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gethash 'a #s(hash-table data (a 1))) =&gt; 1
(gethash 'b #s(hash-table data (a 1))) =&gt; nil
(gethash 'b #s(hash-table data (a 1)) 'hello) =&gt; hello

(<span style="color: #00af00;">setq</span> a #s(hash-table))
(puthash 'yy 19 a) =&gt; 19
(gethash 'yy a) =&gt; 19
(puthash 'yy 20 a) =&gt; 20
(gethash 'yy a) =&gt; 20
(remhash 'yy a) =&gt; nil
(gethash 'yy a) =&gt; nil

(<span style="color: #00af00;">setq</span> a #s(hash-table data (a 1 b 2 c 3)))
(hash-table-count a) =&gt; 3
(hash-table-count (clrhash a)) =&gt; 0

(<span style="color: #00af00;">setq</span> a #s(hash-table data (a 1 b 2 c 3)))
(<span style="color: #00af00;">setq</span> b nil)
(maphash (<span style="color: #00af00;">lambda</span> (k v) (<span style="color: #00af00;">push</span>  (list k v) b)) a)
b =&gt; ((c 3) (b 2) (a 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7021176" class="outline-3">
<h3 id="org7021176"><span class="section-number-3">3.4</span> 自定义哈希函数</h3>
<div class="outline-text-3" id="text-3-4">
<p>
哈希查找分为两个步骤，首先将键哈希化得到哈希值，随后在数组中寻找对应的键值对。要定义新的查找方式需要定义哈希计算函数和哈希比较函数。emacs（27.2）中处理哈希碰撞使用的是拉链法，之所以需要比较函数是因为要在拉链中找到正确的键。
</p>

<p>
这两个函数要求是一致的，即键相同时得到的哈希值也要相同。还需要注意的是，这两个函数可能在任意时刻调用，因此要注意函数要没有副作用且迅速返回，它们的行为应仅取决于键。
</p>

<p>
使用 <code>define-hash-table-test name test-fn hash-fn</code> 可以定义新的哈希 test。定义后你可以在调用 <code>make-hash-table</code> 时使用它作为 <code>:test</code> 参数。当你这样做的时候，你得到的哈希表会使用 test-fn 来比较键的值，使用 hash-fn 来计算键的哈希值。
</p>

<p>
<code>test-fn</code> 要接受两个参数，也就是两个键，当它们相同时应该返回非空值。 <code>hash-fn</code> 接受一个参数，并返回该键对应的哈希值。这两个函数存储在 <code>name</code> 的 plist 中，对应属性是 <code>hash-table-test</code> ，存储形式是 <code>(test-fn hash-fn)</code> 。
</p>

<p>
emacs 默认支持的 test 有三种，分别是 eq, eql 和 equal。它们对应的哈希函数分别是 <code>sxhash-eq</code> ， <code>sxhash-eql</code> 和 <code>sxhash-equal</code> 。关于这三个哈希函数的联系和区别，我会在本文的最后一节简单分析一下它们的 C 实现来说明。
</p>

<p>
下面我们使用 BKDRHash 来作为例子来创建键为字符串的哈希表：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">bkdr-hash</span> (str)
  (<span style="color: #00af00;">let</span> ((hash-v 0))
    (<span style="color: #00af00;">cl-loop</span>
     for a across str
     do (<span style="color: #00af00;">setq</span> hash-v (+ (* hash-v 131) a)))
    (logand hash-v #x7fffffff)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">bkdr-cmp</span> (k1 k2)
  (eq t (compare-strings k1 nil nil k2 nil nil)))

(define-hash-table-test 'bkdr 'bkdr-cmp 'bkdr-hash)

(<span style="color: #00af00;">setq</span> a (make-hash-table <span style="color: #b218b2;">:test</span> 'bkdr))
(<span style="color: #00af00;">cl-loop</span> for i in '((<span style="color: #ff1f8b;">"a"</span> 1) (<span style="color: #ff1f8b;">"b"</span> 2) (<span style="color: #ff1f8b;">"c"</span> 3) (<span style="color: #ff1f8b;">"d"</span> 4))
             do (puthash (car i) (cadr i) a))
(maphash (<span style="color: #00af00;">lambda</span> (k v) (prin1 k) (prin1 v)) a) =&gt; <span style="color: #ff1f8b;">"a"</span>1<span style="color: #ff1f8b;">"b"</span>2<span style="color: #ff1f8b;">"c"</span>3<span style="color: #ff1f8b;">"d"</span>4nil
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org69707ef" class="outline-2">
<h2 id="org69707ef"><span class="section-number-2">4</span> emacs 的多值返回</h2>
<div class="outline-text-2" id="text-4">
<p>
如果你学过一点 common lisp 的话，你会知道 <code>gethash</code> 函数会一下子返回两个值，第一个是键值对的值，第二个是是否找到该键值对的布尔值。就像这样：
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf ht (make-hash-table))
=&gt; #&lt;HASH-TABLE <span style="color: #b218b2;">:TEST</span> EQL <span style="color: #b218b2;">:COUNT</span> 0 {1002C36C03}&gt;
(setf (gethash 1 ht) 2)
(gethash 1 ht)
=&gt;
2
T
(gethash 2 ht)
=&gt;
nil
nil
</pre>
</div>

<p>
而 emacs 中是没有多值返回机制的，它的 <code>gethash</code> 函数只能返回一个值，若哈希表中的键值对的值为 nil，若不使用 default 参数则无法判断该键值对是否在哈希表中。
</p>

<p>
<code>cl-lib</code> 提供了一些多值返回处理函数，不过它使用表来实现的。这里简单介绍一下它提供的功能。
</p>

<ul class="org-ul">
<li><code>cl-values</code> ，类似于 common lisp 的 <code>values</code> ，返回多个值。内部使用 <code>list</code> 实现</li>

<li><code>cl-values-list</code> ，将表中的元素多值返回</li>

<li><code>cl-multiple-value-list</code> ，返回多值返回表达式的所有值组成的表，在 cl-lib 里面使用恒等函数实现</li>

<li><code>cl-multiple-value-apply</code> ，使用多值返回值调用某函数，cl-lib 直接使用 apply 实现。 <code>cl-multiple-value-call</code> 是它的别名</li>

<li><code>cl-multiple-value-setq</code> ，将多值返回得到的值分别赋给对应变量</li>

<li><code>cl-multiple-value-bind</code> ，将多值返回值绑定到变量上</li>
</ul>

<p>
下面我会给出两段代码，第一段是 common lisp ，第二段是 emacs-lisp，来介绍这些函数的使用方法。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(values 1 2) =&gt; 1,2
(values (values 1 2)) =&gt; 1
(values 1 2 (values 2 3)) =&gt; 1,2,2

(values-list '(1 1 2)) =&gt; 1,1,2

(multiple-value-list (values 1 2)) =&gt; (1 2)

(multiple-value-setq (a b c) (values 1 2 3))
(list a b c) =&gt; (1 2 3)

(<span style="color: #00af00;">multiple-value-bind</span> (a b c) (values 1 2 3) (list a b c)) =&gt; (1 2 3)
(multiple-value-call (<span style="color: #00af00;">lambda</span> (x y) (cons x y)) (values 1 2)) =&gt; (1 . 2)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(cl-values 1 2 3) =&gt; (1 2 3)
(cl-values (cl-values 1 2)) =&gt; ((1 2))
(cl-values 1 2 (values 2 3)) =&gt; (1 2 (2 3))

(cl-values-list '(1 1 2)) =&gt; (1 1 2)
(cl-values-list 1) =&gt; Debugger entered--Lisp error: (wrong-type-argument . 1)

(multiple-value-list (cl-values 1 2)) =&gt; (1 2)

(<span style="color: #00af00;">cl-multiple-value-setq</span> (a b c) (cl-values 1 2 3))
(list a b c) =&gt; (1 2 3)

(<span style="color: #00af00;">cl-multiple-value-bind</span> (a b c) (cl-values 1 2 3 4) (list a b c)) =&gt; (1 2 3)

(cl-multiple-value-apply (<span style="color: #00af00;">lambda</span> (x y) (cons x y)) (cl-values 1 2)) =&gt; (1 . 2)
</pre>
</div>
</div>
</div>


<div id="outline-container-org3b91957" class="outline-2">
<h2 id="org3b91957"><span class="section-number-2">5</span> 一个简单的哈希表实现</h2>
<div class="outline-text-2" id="text-5">
<p>
emacs 中的哈希表是使用 C 实现的，代码位于 src/lisp.h 和 src/fns.c 中。下面我使用的代码是 emacs 27.2 的源代码，可以前往<a href="http://mirror.easyname.at/gnu/emacs/">官方网站</a>进行下载。要在线阅读代码的话可以去 github 上的<a href="https://github.com/emacs-mirror/emacs">镜像</a>看看，但是可能和文中使用的代码不完全一致，毕竟最新的 emacs 已经到了 29 了。
</p>

<p>
emacs 中的哈希结构定义在 lisp.h 的 2271 行开始，到 2467 行结束。哈希表的具体实现位于 fns.c 的 3794 至 5070 行。方便起见我就不贴 emacs 中的全部源代码了，对于一篇小文章来说实在是有点多，我尽量按照 emacs 中的哈希表实现来编写我的实现，并给出一些解释。
</p>

<p>
出于便于实现的考虑，我就不实现自定义哈希函数的功能了，直接默认使用 equal 来进行比较。我也不考虑垃圾回收相关的选项，直接使用默认方法，即保护键值对不被回收。关于自动增大倍数和扩容因子，我直接使用默认的 1.5 和 0.8125。
</p>

<p>
下面实现中给出的接口函数有：
</p>

<ul class="org-ul">
<li><code>yyhash-make &amp;optional size</code> ，创建一个哈希表，可以通过 size 指定初始大小</li>

<li><code>yyhash-p obj</code> ，判断对象是否为哈希表</li>

<li><code>yyhash-count obj</code> ，获取哈希表中键值对个数</li>

<li><code>yyhash-size obj</code> ，获取哈希表大小</li>

<li><code>yyhash-get key table &amp;optional default</code> ，查找 key，返回对应值。未找到返回 default</li>

<li><code>yyhash-put key value table</code> ，将键值对放入表中，若已在表中则更新值</li>

<li><code>yyhash-rem key table</code> ，若表中存在 key，则删除 key 对应键值对，否则什么也不做</li>

<li><code>yyhash-clr table</code> ，清空哈希表</li>

<li><code>yyhash-copy table</code> ，创建并返回哈希表副本，与原表共享键值对</li>

<li><code>yyhash-map fn table</code> ，使用 fn 作用于哈希表各键值对</li>
</ul>
</div>

<div id="outline-container-orge37da79" class="outline-3">
<h3 id="orge37da79"><span class="section-number-3">5.1</span> 哈希函数</h3>
<div class="outline-text-3" id="text-5-1">
<p>
如上所言，我会将一些可选项硬编码到代码中，这需要定义一些常量：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--rehash-size</span> 1.5)
(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--rehash-threshold</span> 0.8125)
(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--defsize</span> 65)
</pre>
</div>

<p>
接下来开始编写哈希函数，emacs 中的哈希函数支持符号、字符串、定长整数、浮点数、表、向量、布尔向量和大整数。这里稍作简化，只支持符号、定长整数、浮点数、字符串、表和向量。在下面实现的哈希函数包括：
</p>

<ul class="org-ul">
<li><code>yyhash--fixnum</code> ，计算定长整数哈希</li>

<li><code>yyhash--symbol</code> ，计算符号哈希</li>

<li><code>yyhash--string</code> ，计算字符串哈希</li>

<li><code>yyhash--float</code> ，计算浮点数哈希</li>

<li><code>yyhash--list</code> ，计算表哈希</li>

<li><code>yyhash--vec</code> ，计算向量哈希</li>

<li><code>yyhash-hash</code> ，整合函数</li>
</ul>
</div>

<div id="outline-container-org4efd91f" class="outline-4">
<h4 id="org4efd91f"><span class="section-number-4">5.1.1</span> 定长整数</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
对于定长整数，emacs 直接返回该整数值，故整数哈希值可以直接用整数值：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h</span>
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">lisp_h_XLI</span>(<span style="color: #ff8700;">o</span>) ((EMACS_INT) (o))
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">XLI</span>(<span style="color: #ff8700;">o</span>) lisp_h_XLI (o)
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 1238</span>
<span style="color: #ef2929;">XUFIXNUM_RAW</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">a</span>)
{
    <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">i</span> = XLI (a);
    <span style="color: #00af00;">return</span> USE_LSB_TAG ? i &gt;&gt; INTTYPEBITS : i &amp; INTMASK;
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 1243</span>
INLINE <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">XUFIXNUM</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">a</span>)
{
    eassert (FIXNUMP (a));
    <span style="color: #00af00;">return</span> XUFIXNUM_RAW (a);
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4687</span>
    <span style="color: #1f5bff;">case_Lisp_Int</span>:
      hash = XUFIXNUM (obj);
      <span style="color: #00af00;">break</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defsubst</span> <span style="color: #ef2929;">yyhash--fixnum</span> (n)
  <span style="color: #cc0000;">"hash for fixnum"</span>
  n)
</pre>
</div>
</div>
</div>

<div id="outline-container-org32499b3" class="outline-4">
<h4 id="org32499b3"><span class="section-number-4">5.1.2</span> 符号</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
对于符号，emacs 返回符号的指针值，由于使用 elisp 拿不到指针值，我也就不能使用这种方法。我想到的办法是将符号转为字符串后使用字符串哈希处理，不过这样一来字符串和符号也就没什么区别了。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4691</span>
<span style="color: #00af00;">case</span> Lisp_Symbol:
hash = XHASH (obj);
<span style="color: #00af00;">break</span>;
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 398</span>
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">lisp_h_XHASH</span>(<span style="color: #ff8700;">a</span>) XUFIXNUM_RAW (a)
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">XHASH</span>(<span style="color: #ff8700;">a</span>) lisp_h_XHASH (a)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defsubst</span> <span style="color: #ef2929;">yyhash--symbol</span> (s)
  <span style="color: #cc0000;">"hash for symbol, use string's hash function"</span>
  (yyhash--string (symbol-name s)))
</pre>
</div>

<p>
除了自己计算符号的哈希值，我们也可以使用 emacs 提供的 <code>sxhash-eq</code> ，它使用 <code>Lisp_Object</code> 对象的值来计算哈希值。
</p>
</div>
</div>

<div id="outline-container-org8684036" class="outline-4">
<h4 id="org8684036"><span class="section-number-4">5.1.3</span> 字符串</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
对于字符串，emacs 的 sxhash_string 已经给出了实现，这里直接抄过来。这里给出 <code>hash--combine</code> 和 <code>hash--reduce</code> 两个函数的定义，它们用于处理字节。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4557</span>
<span style="color: #ef2929;">hash_string</span> (<span style="color: #18b2b2;">char</span> <span style="color: #00af00;">const</span> *<span style="color: #ff8700;">ptr</span>, <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">len</span>)
{
  <span style="color: #18b2b2;">char</span> <span style="color: #00af00;">const</span> *<span style="color: #ff8700;">p</span> = ptr;
  <span style="color: #18b2b2;">char</span> <span style="color: #00af00;">const</span> *<span style="color: #ff8700;">end</span> = p + len;
  <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">char</span> <span style="color: #ff8700;">c</span>;
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash</span> = 0;

  <span style="color: #00af00;">while</span> (p != end)
    {
      c = *p++;
      hash = sxhash_combine (hash, c);
    }

  <span style="color: #00af00;">return</span> hash;
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 2454</span>
INLINE <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">sxhash_combine</span> (<span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">x</span>, <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">y</span>)
{
  <span style="color: #00af00;">return</span> (x &lt;&lt; 4) + (x &gt;&gt; (EMACS_INT_WIDTH - 4)) + y;
}

<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4577</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">sxhash_string</span> (<span style="color: #18b2b2;">char</span> <span style="color: #00af00;">const</span> *<span style="color: #ff8700;">ptr</span>, <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">len</span>)
{
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash</span> = hash_string (ptr, len);
  <span style="color: #00af00;">return</span> SXHASH_REDUCE (hash);
}

<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 2463</span>
INLINE <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">SXHASH_REDUCE</span> (<span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">x</span>)
{
  <span style="color: #00af00;">return</span> (x ^ x &gt;&gt; (EMACS_INT_WIDTH - FIXNUM_BITS)) &amp; INTMASK;
}
</pre>
</div>

<p>
C 使用的是 8 比特字节数组来计算字符串哈希，这里我们可以考虑把每个字符打断成 8 字节来处理。具体的编码我就不关心了。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defsubst</span> <span style="color: #ef2929;">yyhash--combine</span> (x y)
  <span style="color: #cc0000;">"emacs use 61 bit for fixnum"</span>
  (+ (lsh x 4) (lsh x -57) y))

(<span style="color: #00af00;">defsubst</span> <span style="color: #ef2929;">yyhash--reduce</span> (n)
  <span style="color: #cc0000;">"reduce to not great than fixnum max value"</span>
  (logand (logxor n (lsh n -3)) most-positive-fixnum))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--string</span> (s)
  <span style="color: #cc0000;">"hash for string"</span>
  (<span style="color: #00af00;">let</span> ((hash 0))
    (<span style="color: #00af00;">cl-loop</span>
     for i across s
     do (<span style="color: #00af00;">cl-loop</span> for x = i then (lsh x -8)
                 do (<span style="color: #00af00;">setq</span> hash (yyhash--combine hash (logand x #xff)))
                 when (&lt;= x #xff) return 0))
    (yyhash--reduce hash)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb562dcc" class="outline-4">
<h4 id="orgb562dcc"><span class="section-number-4">5.1.4</span> 浮点数</h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
对于浮点数的处理，hashtable C 实现把 double 类型浮点数看作八个字节来处理。由于 elisp 同样拿不到浮点数的各个字节，这里就有了两种思路。一是将浮点数转字符串然后交给 <code>yyhash--string</code> 处理，二是通过浮点值推得最接近的 IEEE-754 表示，再进行哈希化。这里采用第二种方法（反正就是个玩具，随意吧）。咱的这个实现比较粗糙，准确性和性能可能不是很好。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4585</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">sxhash_float</span> (<span style="color: #18b2b2;">double</span> <span style="color: #ff8700;">val</span>)
{
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash</span> = 0;
  <span style="color: #00af00;">union</span> <span style="color: #18b2b2;">double_and_words</span> <span style="color: #ff8700;">u</span> = { .val = val };
  <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; WORDS_PER_DOUBLE; i++)
    hash = sxhash_combine (hash, u.word[i]);
  <span style="color: #00af00;">return</span> SXHASH_REDUCE (hash);
}
</pre>
</div>


<div id="org89da6ba" class="figure">
<p><img src="./5.png" alt="5.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-float2list</span> (m)
  <span style="color: #cc0000;">"double to ieee-754 representation</span>
<span style="color: #cc0000;">return a list, cadr is 0 to 55th bit, car is 56th to 63th bit"</span>
  (<span style="color: #00af00;">let*</span> ((sgn (cl-signum m))
         (abm (abs m))
         (exp-n (truncate (log abm 2)))
         (exp-bias (+ exp-n 1023))
         (num (/ abm (expt 2 exp-n)))
         (num52 (logand (floor (* num (lsh 1 52)))
                        (1- (lsh 1 52))))
         (num56 (+ num52 (lsh (logand 15 exp-bias) 52)))
         (num8 (<span style="color: #00af00;">if</span> (= sgn -1) (+ 128 (lsh exp-bias -4)) (lsh exp-bias -4))))
    (cl-values num8 num56)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--float</span> (m)
  <span style="color: #cc0000;">"hash for float"</span>
  (<span style="color: #00af00;">if</span> (<span style="color: #00af00;">or</span> (isnan m)
          (= (abs m) 1.0e+INF))
      0
    (<span style="color: #00af00;">cl-multiple-value-bind</span> (a b) (yyhash-float2list m)
      (<span style="color: #00af00;">let</span> ((hash a))
        (<span style="color: #00af00;">cl-loop</span>
         for x = b then (lsh x -8)
         do (<span style="color: #00af00;">setq</span> hash (yyhash--combine hash (logand x #xff)))
         when (&lt;= x #xff) return (yyhash--reduce hash))))))
</pre>
</div>

<p>
除了自己解析，我们也可以使用 <code>sxhash-eql</code> 来计算浮点数哈希值。
</p>
</div>
</div>

<div id="outline-container-orga9b2adc" class="outline-4">
<h4 id="orga9b2adc"><span class="section-number-4">5.1.5</span> 表和向量</h4>
<div class="outline-text-4" id="text-5-1-5">
<p>
接下来就是作为序列的表和向量了。因为这两种对象都是可以嵌套的，而且它们长度不定，所以需要添加一些约束，在 emacs 实现中限制作为哈希输入的最长长度为 7，最深嵌套为 3 层，这些措施显然是考虑到了哈希函数的计算时间。我们也仿照加上限制。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b218b2;">#define</span> <span style="color: #ff8700;">SXHASH_MAX_DEPTH</span> 3
<span style="color: #b218b2;">#define</span> <span style="color: #ff8700;">SXHASH_MAX_LEN</span>   7
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--max-depth</span> 3 <span style="color: #cc0000;">"max depth for nest struct"</span>)
(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--max-len</span> 7 <span style="color: #cc0000;">"max length for list and vector"</span>)
</pre>
</div>

<p>
由于表中元素并不一定是表或向量，所以需要将所有函数合起来成一个函数才能处理表和向量，我们先将这个合体函数命名为 <code>yyhash--hashfn</code> ，对表或向量求哈希值的过程会用到互递归。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4598</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">sxhash_list</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">list</span>, <span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">depth</span>)
{
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash</span> = 0;
  <span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span>;

  <span style="color: #00af00;">if</span> (depth &lt; SXHASH_MAX_DEPTH)
    <span style="color: #00af00;">for</span> (i = 0;
         CONSP (list) &amp;&amp; i &lt; SXHASH_MAX_LEN;
         list = XCDR (list), ++i)
      {
        <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash2</span> = sxhash (XCAR (list), depth + 1);
        hash = sxhash_combine (hash, hash2);
      }

  <span style="color: #00af00;">if</span> (<span style="color: #cc0000;">!</span>NILP (list))
    {
      <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash2</span> = sxhash (list, depth + 1);
      hash = sxhash_combine (hash, hash2);
    }

  <span style="color: #00af00;">return</span> SXHASH_REDUCE (hash);
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4626</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">EMACS_UINT</span>
<span style="color: #ef2929;">sxhash_vector</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">vec</span>, <span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">depth</span>)
{
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash</span> = ASIZE (vec);
  <span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span>, <span style="color: #ff8700;">n</span>;

  n = min (SXHASH_MAX_LEN, hash &amp; PSEUDOVECTOR_FLAG ? PVSIZE (vec) : hash);
  <span style="color: #00af00;">for</span> (i = 0; i &lt; n; ++i)
    {
      <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">hash2</span> = sxhash (AREF (vec, i), depth + 1);
      hash = sxhash_combine (hash, hash2);
    }

  <span style="color: #00af00;">return</span> SXHASH_REDUCE (hash);
}
</pre>
</div>

<p>
以下是 elisp 实现代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--list</span> (ls depth)
  <span style="color: #cc0000;">"hash for list"</span>
  (<span style="color: #00af00;">let</span> ((hash 0))
    (<span style="color: #00af00;">when</span> (&lt; depth yyhash--max-depth)
      (<span style="color: #00af00;">do</span> ((i 0 (+ i 1)))
          ((not (<span style="color: #00af00;">and</span> (consp ls) (&lt; i yyhash--max-len))))
        (<span style="color: #00af00;">let</span> ((hash2 (yyhash--hashfn (car ls) (1+ depth))))
          (<span style="color: #00af00;">setq</span> hash (yyhash--combine hash hash2))
          (<span style="color: #00af00;">pop</span> ls))))
    (<span style="color: #00af00;">when</span> (not (null ls))
      (<span style="color: #00af00;">let</span> ((hash2 (yyhash--hashfn ls (1+ depth))))
        (<span style="color: #00af00;">setq</span> hash (yyhash--combine hash hash2))))
    (yyhash--reduce hash)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--vec</span> (v depth)
  <span style="color: #cc0000;">"hash for vector"</span>
  (<span style="color: #00af00;">let*</span> ((hash (length v))
         (n (min yyhash--max-len hash)))
    (<span style="color: #00af00;">cl-loop</span>
     for i below n
     do (<span style="color: #00af00;">setq</span> hash (yyhash--combine
                    hash
                    (yyhash--hashfn (aref v i) (1+ depth)))))
    (yyhash--reduce hash)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2aceea" class="outline-4">
<h4 id="orgb2aceea"><span class="section-number-4">5.1.6</span> 整合与测试</h4>
<div class="outline-text-4" id="text-5-1-6">
<p>
现在我们可以通过将这些函数组装在一起完成整个哈希函数了。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--hashfn</span> (obj depth)
  <span style="color: #cc0000;">"hash function"</span>
  (<span style="color: #00af00;">if</span> (&gt; depth yyhash--max-depth) 0
    (<span style="color: #00af00;">let</span> ((tp (type-of obj)))
      (<span style="color: #00af00;">cl-case</span> tp
        ((integer) (<span style="color: #00af00;">if</span> (fixnump obj)
                       (yyhash--fixnum obj)
                     (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"not a fixnum obj: %d"</span> obj)))
        ((symbol) (yyhash--symbol obj))
        ((string) (yyhash--string obj))
        ((float) (yyhash--float obj))
        ((cons) (yyhash--list obj depth))
        ((vector) (yyhash--vec obj depth))
        (otherwise (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"unknown type obj: %s"</span> obj))))))
</pre>
</div>

<p>
下面来做一些简单的测试：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">fixnum</span>
(yyhash--hashfn 109 0) =&gt; 109
(yyhash--hashfn -1 0) =&gt; -1
(yyhash--hashfn 0 0) =&gt; 0

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">symbol and string</span>
(yyhash--hashfn 'a 0) =&gt; 109
(yyhash--hashfn <span style="color: #ff1f8b;">"a"</span> 0) =&gt; 109
(yyhash--hashfn <span style="color: #ff1f8b;">"abcdefghijklmnopqrstuvwxyz"</span> 0) =&gt; 517678880143323409
(yyhash--hashfn 'abcdefghijklmnopqrstuvwxyz 0) =&gt; 517678880143323409

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">float</span>
(yyhash--hashfn 1.0 0) =&gt; 15267266798
(yyhash--hashfn 1.0e+INF 0) =&gt; 0
(yyhash--hashfn 0.0e+NaN 0) =&gt; 0
(yyhash--hashfn 1.12 0) =&gt; 19292961333

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">list</span>
(yyhash--hashfn '(1) 0) =&gt; 1
(yyhash--hashfn '(<span style="color: #ff1f8b;">"a"</span> <span style="color: #ff1f8b;">"b"</span> <span style="color: #ff1f8b;">"c"</span>) 0) =&gt; 31430
(yyhash--hashfn '((1) (2) [3 4] <span style="color: #ff1f8b;">"a"</span> 0.1) 0) =&gt; 20832553980

<span style="color: #b2b2b2; font-style: italic;">;;</span><span style="color: #b2b2b2; font-style: italic;">vector</span>
(yyhash--hashfn [1] 0) =&gt; 19
(yyhash--hashfn [[1 2] [3 4] [(5 6)]] 0) =&gt; 193393
</pre>
</div>

<p>
到此为止，我们就完成了哈希函数的编写。下面我们介绍一下三个默认的哈希函数，即 <code>sxhash-eq</code> ， <code>sxhash-eql</code> 和 <code>sxhash-equal</code> 。
</p>
</div>
</div>

<div id="outline-container-org93a1523" class="outline-4">
<h4 id="org93a1523"><span class="section-number-4">5.1.7</span> emacs 中实现的哈希函数</h4>
<div class="outline-text-4" id="text-5-1-7">
<p>
反正有的是时间，我就把三种比较函数 <code>eq</code> ， <code>eql</code> 和 <code>equal</code> 的 C 实现都读了一遍，下面我们来分析一下它们的区别。
</p>

<p>
首先是 EQ，它位于 lisp.h 和 data.c 内。具体定义如下：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">lisp_h_XLI</span>(<span style="color: #ff8700;">o</span>) ((EMACS_INT) (o)) <span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 344</span>
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">XLI</span>(<span style="color: #ff8700;">o</span>) lisp_h_XLI (o) <span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 426</span>
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">lisp_h_EQ</span>(<span style="color: #ff8700;">x</span>, <span style="color: #ff8700;">y</span>) (XLI (x) == XLI (y)) <span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 373</span>
<span style="color: #b218b2;">#define</span> <span style="color: #ef2929;">EQ</span>(<span style="color: #ff8700;">x</span>, <span style="color: #ff8700;">y</span>) lisp_h_EQ (x, y) <span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">lisp.h 434</span>

<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">data.c 185</span>
DEFUN (<span style="color: #ff1f8b;">"eq"</span>, Feq, Seq, 2, 2, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Return t if the two args are the same Lisp object.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>
       attributes: <span style="color: #00af00;">const</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">obj1</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">obj2</span>)
{
  <span style="color: #00af00;">if</span> (EQ (obj1, obj2))
    <span style="color: #00af00;">return</span> Qt;
  <span style="color: #00af00;">return</span> Qnil;
}
</pre>
</div>

<p>
可见 <code>eq</code> 比较的就是 <code>Lisp_Object</code> 值。 <code>Lisp_Object</code> 是 Emacs 中的对象类型，它是 64 位整数，用来唯一标识一个对象，可以和 Windows 中的句柄类比。它其中要包含 3 位的类型标识，用来区分基础类型，其余位用来存放数据或指针，这也就是为什么 emacs 的 fixnum 只有 61 位的原因。 <code>eq</code> 相等的条件就是基本类型相同且指针（或数据）相同。
</p>

<p>
<code>eql</code> 相比于 <code>eq</code> 放宽了条件，它的定义如下：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 2296</span>
DEFUN (<span style="color: #ff1f8b;">"eql"</span>, Feql, Seql, 2, 2, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Return t if the two args are `eq' or are indistinguishable numbers.</span>
<span style="color: #b2b2b2; font-style: italic;">Floating-point values with the same sign, exponent and fraction are `eql'.</span>
<span style="color: #b2b2b2; font-style: italic;">This differs from numeric comparison: (eql 0.0 -0.0) returns nil and</span>
<span style="color: #b2b2b2; font-style: italic;">\(eql 0.0e+NaN 0.0e+NaN) returns t, whereas `=' does the opposite.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">obj1</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">obj2</span>)
{
  <span style="color: #00af00;">if</span> (FLOATP (obj1))
    <span style="color: #00af00;">return</span> FLOATP (obj2) &amp;&amp; same_float (obj1, obj2) ? Qt : Qnil;
  <span style="color: #00af00;">else</span> <span style="color: #00af00;">if</span> (BIGNUMP (obj1))
    <span style="color: #00af00;">return</span> ((BIGNUMP (obj2)
             &amp;&amp; mpz_cmp (*xbignum_val (obj1), *xbignum_val (obj2)) == 0)
            ? Qt : Qnil);
  <span style="color: #00af00;">else</span>
    <span style="color: #00af00;">return</span> EQ (obj1, obj2) ? Qt : Qnil;
}
<span style="color: #b2b2b2; font-style: italic;">// </span><span style="color: #b2b2b2; font-style: italic;">fns.c 1536</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">bool</span>
<span style="color: #ef2929;">same_float</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">x</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">y</span>)
{
  <span style="color: #00af00;">union</span> <span style="color: #18b2b2;">double_and_words</span>
    <span style="color: #ff8700;">xu</span> = { .val = XFLOAT_DATA (x) },
    <span style="color: #ff8700;">yu</span> = { .val = XFLOAT_DATA (y) };
  <span style="color: #18b2b2;">EMACS_UINT</span> <span style="color: #ff8700;">neql</span> = 0;
  <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; WORDS_PER_DOUBLE; i++)
    neql |= xu.word[i] ^ yu.word[i];
  <span style="color: #00af00;">return</span> <span style="color: #cc0000;">!</span>neql;
}

</pre>
</div>

<p>
相比于 <code>eq</code> ，它在数字处理上多做了些工作。若数字是浮点类型，由于 61 位放不下 8 字节的双精度值，它就必须存放在别处， <code>Lisp_Object</code> 中存放指向它的指针值. <code>(eq 1.0 1.0)</code> 会得到 nil 值，因为这两个数字的地址并不同。使用 <code>eql</code> 比较浮点数时，emacs 会逐字节比较，若完全相同则返回真。
</p>

<p>
对于大整数，它使用了 gmp 库中的函数进行比较。这里我就不列举了。
</p>

<p>
最后是 <code>equal</code> ，它相比 <code>eql</code> 更进一步，直接比较各对象的值而非“句柄”值。它使用的函数 <code>internal_equal</code> 位于 fns.c 的 2357 行，结束于 2512 行，有点长这里就不贴了。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 2313</span>
DEFUN (<span style="color: #ff1f8b;">"equal"</span>, Fequal, Sequal, 2, 2, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Return t if two Lisp objects have similar structure and contents.</span>
<span style="color: #b2b2b2; font-style: italic;">They must have the same data type.</span>
<span style="color: #b2b2b2; font-style: italic;">Conses are compared by comparing the cars and the cdrs.</span>
<span style="color: #b2b2b2; font-style: italic;">Vectors and strings are compared element by element.</span>
<span style="color: #b2b2b2; font-style: italic;">Numbers are compared via `eql', so integers do not equal floats.</span>
<span style="color: #b2b2b2; font-style: italic;">\(Use `=' if you want integers and floats to be able to be equal.)</span>
<span style="color: #b2b2b2; font-style: italic;">Symbols must match exactly.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">o1</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">o2</span>)
{
  <span style="color: #00af00;">return</span> internal_equal (o1, o2, EQUAL_PLAIN, 0, Qnil) ? Qt : Qnil;
}
</pre>
</div>

<p>
下面是三种比较函数对应的三种哈希函数，可见 <code>hashfn_eq</code> 是最简单的， <code>hashfn-eql</code> 多处理了浮点和大整数，而 <code>hashfn-equal</code> 直接调用了通用哈希函数 <code>sxhash</code> 来得到哈希值。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">// </span><span style="color: #b2b2b2; font-style: italic;">fns.c 4013</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">Lisp_Object</span>
<span style="color: #ef2929;">hashfn_eq</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>)
{
  <span style="color: #00af00;">return</span> make_ufixnum (XHASH (key) ^ XTYPE (key));
}

<span style="color: #b2b2b2; font-style: italic;">// </span><span style="color: #b2b2b2; font-style: italic;">fns.c 4032</span>
<span style="color: #18b2b2;">Lisp_Object</span>
<span style="color: #ef2929;">hashfn_eql</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>)
{
  <span style="color: #00af00;">return</span> (FLOATP (key) || BIGNUMP (key) ? hashfn_equal : hashfn_eq) (key, h);
}

<span style="color: #b2b2b2; font-style: italic;">// </span><span style="color: #b2b2b2; font-style: italic;">fns.c 4022</span>
<span style="color: #18b2b2;">Lisp_Object</span>
<span style="color: #ef2929;">hashfn_equal</span> (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>)
{
  <span style="color: #00af00;">return</span> make_ufixnum (sxhash (key, 0));
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0e841e7" class="outline-3">
<h3 id="org0e841e7"><span class="section-number-3">5.2</span> 哈希表的结构定义</h3>
<div class="outline-text-3" id="text-5-2">
<p>
接下来就是哈希结构体的定义了，这和具体的 C 实现方式是相关的。 <code>Lisp_Hash_Table</code> 的定义位于 lisp.h 的 2297 行到 2371 行，其中包括了许多我的实现中不需要的 slot。这里我摘取必要的 slot 来创建一个名为 yyhash 的 record 类型：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">cl-defstruct</span> (<span style="color: #18b2b2;">yyhash</span>
               (<span style="color: #b218b2;">:conc-name</span> yyhash--s-)
               (<span style="color: #b218b2;">:constructor</span> yyhash--s-create)
               (<span style="color: #b218b2;">:copier</span> nil)
               (<span style="color: #b218b2;">:predicate</span> yyhash-p))
  <span style="color: #cc0000;">"yy's hash table struct"</span>
  (hash nil <span style="color: #b218b2;">:type</span> vector
        <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"vector of hash codes.</span>
<span style="color: #cc0000;">if entry I is free, hash[i] should be nil"</span>)
  (next nil <span style="color: #b218b2;">:type</span> vector
        <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"vector used to chain entries"</span>)
  (index nil <span style="color: #b218b2;">:type</span> vector
         <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"Bucket vector."</span>)
  (count 0 <span style="color: #b218b2;">:type</span> integer
         <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"Number of key/value entries in the table"</span>)
  (next-free 0 <span style="color: #b218b2;">:type</span> integer
             <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"index of first free entry in free list,</span>
<span style="color: #cc0000;">or -1 if none"</span>)
  (key-and-value nil <span style="color: #b218b2;">:type</span> vector
                 <span style="color: #b218b2;">:documentation</span> <span style="color: #cc0000;">"vector of keys and values.</span>
<span style="color: #cc0000;">key of item I is at index (* I 2), value is at (1+ (* I 2))"</span>))
</pre>
</div>

<p>
下面简单说说各 slot 的作用：
</p>

<ul class="org-ul">
<li><code>hash</code> ，存放哈希值的向量。若对应位置 entry 不存在则对应位置值为 nil</li>
<li><code>next</code> ，记录 entry 链的向量。它有两个功能，若哈希表的第 I 项为空，那么它的第 I 项的值为下一个哈希表空项的序号值，这时它的作用是管理空闲存储空间。若哈希表第 I 项含 entry，那么它的第 I 项是冲突链上的下一个 entry 序号，可以用来寻找相同哈希值的下一 entry</li>
<li><code>index</code> ，记录哈希 entry 序号的向量，也就是哈希桶。若第 I 项为 -1 说明哈希表的第 I 项是空的，否则第 I 项的值是冲突链的第一个 entry 的序号。这个向量可以大于哈希表实际大小以减少冲突</li>
<li><code>count</code> ，哈希表中的 entry 个数</li>
<li><code>next-free</code> ，哈希表中的第一个空闲位置的序号</li>
<li><code>key-and-value</code> ，存放键值对的向量，长度是哈希表大小的两倍。第 I 个 entry 的键和值分别位于 2 * I 和 2 * I + 1</li>
</ul>

<p>
emacs 中处理哈希冲突的方法是拉链法，不过使用的是静态链表，它使用 <code>next</code> 和 <code>next-free</code> 来管理 <code>key-and-value</code> 这块存储空间，这里我们用一张图来展示一下各 slot 的作用：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./7.PNG" alt="7.PNG" /></td>
</tr>
</tbody>
</table>

<p>
出于方便的需要，我们还要定义一系列的 getter/setter 函数，它们用来获取和修改结构中向量的值。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--symbol-concat</span> (<span style="color: #18b2b2;">&amp;rest</span> names)
  <span style="color: #cc0000;">"generate symbol from string"</span>
  (intern (apply 'concat (mapcar 'symbol-name names))))

(<span style="color: #00af00;">defmacro</span> <span style="color: #ef2929;">yyhash--s-gen-get/setter</span> (prefix slots)
  <span style="color: #cc0000;">"generate vector getter and setter"</span>
  (<span style="color: #00af00;">let</span> ((names-get (mapcar (<span style="color: #00af00;">lambda</span> (x)
                             (yyhash--symbol-concat prefix x '-getv))
                           slots))
        (names-set (mapcar (<span style="color: #00af00;">lambda</span> (x)
                             (yyhash--symbol-concat prefix x '-setv))
                           slots))
        (res nil))
    (<span style="color: #00af00;">cl-loop</span> for i in names-get
             for j in names-set
             for k in slots
             do (<span style="color: #00af00;">push</span> `(<span style="color: #00af00;">defsubst</span> ,i (yh n)
                         (aref (cl-struct-slot-value 'yyhash ',k yh) n))
                      res)
             do (<span style="color: #00af00;">push</span> `(<span style="color: #00af00;">defsubst</span> ,j (yh n newval)
                         (aset (cl-struct-slot-value 'yyhash ',k yh) n newval))
                      res))
    (cons 'progn res)))

(yyhash--s-gen-get/setter yyhash--
                          (hash
                           next
                           index
                           key-and-value))
</pre>
</div>

<p>
下面我们开始编写哈希表创建函数，它接受一个可选的大小参数，并返回哈希表对象。考虑到毕竟是个玩具哈希表，哈希表的最大容量就取十万吧。原函数的定义位于 fns.c 的 4115 行和 4768 行。下面的 <code>yyhash--next-almost-prime</code> 用来计算离 n 最近的伪素数，可能使用素数作为哈希桶大小有利于减少冲突。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defconst</span> <span style="color: #ff8700;">yyhash--biggest</span> 100000)

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--next-almost-prime</span> (n)
  <span style="color: #cc0000;">"create a pesudo prime number bigger then n"</span>
  (<span style="color: #00af00;">do</span> ((n (logior n 1) (+ n 2)))
      ((<span style="color: #00af00;">and</span> (not (zerop (% n 3)))
            (not (zerop (% n 5)))
            (not (zerop (% n 7))))
       n)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-make</span> (<span style="color: #18b2b2;">&amp;optional</span> size)
  <span style="color: #cc0000;">"make a hash table. size must be nonnegative integer if provided"</span>
  (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (<span style="color: #00af00;">or</span> (null size) (<span style="color: #00af00;">and</span> (integerp size) (&gt;= size 0))))
  (<span style="color: #00af00;">let*</span> ((size (<span style="color: #00af00;">if</span> size (<span style="color: #00af00;">if</span> (= size 0) 1 size) yyhash--defsize))
         (h-size (min size yyhash--biggest))
         (k-v (make-vector (* h-size 2) nil))
         (next (make-vector h-size -1))
         (i-size (yyhash--next-almost-prime
                  (floor (/ h-size yyhash--rehash-threshold))))
         (index (make-vector i-size -1))
         (hash (make-vector h-size nil)))
    (<span style="color: #00af00;">do</span> ((i 0 (+ i 1)))
        ((= i (1- h-size)))
      (aset next i (+ i 1)))
    (yyhash--s-create
     <span style="color: #b218b2;">:hash</span> hash <span style="color: #b218b2;">:next</span> next <span style="color: #b218b2;">:index</span> index <span style="color: #b218b2;">:key-and-value</span> k-v
     <span style="color: #b218b2;">:count</span> 0 <span style="color: #b218b2;">:next-free</span> 0)))
</pre>
</div>

<p>
<code>cl-defstruct</code> 已经帮我们生成了 <code>yyhash--s-count</code> 和 <code>yyhash-p</code> 函数，再加上已经完成的 <code>yyhash-make</code> ，我们已经完成了 3 个函数，下面我们来实现哈希表的复制和获取大小。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">// </span><span style="color: #b2b2b2; font-style: italic;">fns.c 4165</span>
<span style="color: #00af00;">static</span> <span style="color: #18b2b2;">Lisp_Object</span>
<span style="color: #ef2929;">copy_hash_table</span> (<span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h1</span>)
{
  <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">table</span>;
  <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h2</span>;

  h2 = allocate_hash_table ();
  *h2 = *h1;
  h2-&gt;mutable = <span style="color: #1f5bff;">true</span>;
  h2-&gt;key_and_value = Fcopy_sequence (h1-&gt;key_and_value);
  h2-&gt;hash = Fcopy_sequence (h1-&gt;hash);
  h2-&gt;next = Fcopy_sequence (h1-&gt;next);
  h2-&gt;index = Fcopy_sequence (h1-&gt;index);
  XSET_HASH_TABLE (table, h2);

  <span style="color: #00af00;">return</span> table;
}
</pre>
</div>

<p>
<code>yyhash-copy</code> 的作用是复制一个哈希表，它的键值对与原表共享。 <code>yyhash-count</code> 获取哈希表内 entry 个数， <code>yyhash-size</code> 获取哈希表的大小，而 <code>yyhash--isize</code> 获取哈希桶向量 <code>index</code> 的大小。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-copy</span> (yh)
  <span style="color: #cc0000;">"make a copy of hash table"</span>
  (<span style="color: #00af00;">let</span> ((k-v (copy-sequence (yyhash--s-key-and-value yh)))
        (hash (copy-sequence (yyhash--s-hash yh)))
        (next (copy-sequence (yyhash--s-next yh)))
        (index (copy-sequence (yyhash--s-index yh))))
    (yyhash--s-create
     <span style="color: #b218b2;">:hash</span> hash <span style="color: #b218b2;">:next</span> next <span style="color: #b218b2;">:index</span> index <span style="color: #b218b2;">:key-and-value</span> k-v
     <span style="color: #b218b2;">:count</span> (yyhash--s-count yh)
     <span style="color: #b218b2;">:next-free</span> (yyhash--s-next-free yh))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-count</span> (yh)
  <span style="color: #cc0000;">"get number of entry in hash table"</span>
  (yyhash--s-count yh))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-size</span> (yh)
  <span style="color: #cc0000;">"get size of hash table"</span>
  (length (yyhash--s-hash yh)))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--isize</span> (yh)
  <span style="color: #cc0000;">"get size of bucket vector of hashtable"</span>
  (length (yyhash--s-index yh)))
</pre>
</div>

<p>
这样一来就完成了 5 个函数。
</p>
</div>
</div>


<div id="outline-container-org798bfdb" class="outline-3">
<h3 id="org798bfdb"><span class="section-number-3">5.3</span> 哈希表的查找、删除与遍历</h3>
<div class="outline-text-3" id="text-5-3">
<p>
由于加入键值对会涉及到哈希表的扩容，这里我们从比较简单的查找和删除开始。
</p>
</div>

<div id="outline-container-orgd1aa1ad" class="outline-4">
<h4 id="orgd1aa1ad"><span class="section-number-4">5.3.1</span> 查找</h4>
<div class="outline-text-4" id="text-5-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4307</span>
<span style="color: #18b2b2;">ptrdiff_t</span>
<span style="color: #ef2929;">hash_lookup</span> (<span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #18b2b2;">Lisp_Object</span> *<span style="color: #ff8700;">hash</span>)
{
  <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">start_of_bucket</span>, <span style="color: #ff8700;">i</span>;

  hash_rehash_if_needed (h);

  <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">hash_code</span> = h-&gt;test.hashfn (key, h);
  <span style="color: #00af00;">if</span> (hash)
    *hash = hash_code;

  start_of_bucket = XUFIXNUM (hash_code) % ASIZE (h-&gt;index);

  <span style="color: #00af00;">for</span> (i = HASH_INDEX (h, start_of_bucket); 0 &lt;= i; i = HASH_NEXT (h, i))
    <span style="color: #00af00;">if</span> (EQ (key, HASH_KEY (h, i))
        || (h-&gt;test.cmpfn
            &amp;&amp; EQ (hash_code, HASH_HASH (h, i))
            &amp;&amp; <span style="color: #cc0000;">!</span>NILP (h-&gt;test.cmpfn (key, HASH_KEY (h, i), h))))
      <span style="color: #00af00;">break</span>;

  <span style="color: #00af00;">return</span> i;
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4991</span>
DEFUN (<span style="color: #ff1f8b;">"gethash"</span>, Fgethash, Sgethash, 2, 3, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Look up KEY in TABLE and return its associated value.</span>
<span style="color: #b2b2b2; font-style: italic;">If KEY is not found, return DFLT which defaults to nil.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">table</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">dflt</span>)
{
  <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span> = check_hash_table (table);
  <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">i</span> = hash_lookup (h, key, <span style="color: #1f5bff;">NULL</span>);
  <span style="color: #00af00;">return</span> i &gt;= 0 ? HASH_VALUE (h, i) : dflt;
}
</pre>
</div>

<p>
以下是对应 <code>yyhash-get</code> 的实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--lookup</span> (key yh <span style="color: #18b2b2;">&amp;optional</span> cons-pt)
  <span style="color: #cc0000;">"look key in yh hastable, set car of cons-pt to hash code if provided"</span>
  (<span style="color: #00af00;">let*</span> ((hash-code (yyhash--hashfn key 0))
         (start-of-bucket (% hash-code (yyhash--isize yh)))
         (find-i
          (<span style="color: #00af00;">do</span> ((i (yyhash--index-getv yh start-of-bucket)
                  (yyhash--next-getv yh i)))
              ((<span style="color: #00af00;">or</span> (&lt; i 0)
                   (<span style="color: #00af00;">and</span>
                    (equal key (yyhash--key yh i))
                    (= hash-code (yyhash--hash-getv yh i))))
               i))))
    (<span style="color: #00af00;">when</span> cons-pt (setcar cons-pt hash-code))
    find-i))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-get</span> (key yh <span style="color: #18b2b2;">&amp;optional</span> default)
  <span style="color: #cc0000;">"get entry's value, or default(nil) if not found"</span>
  (<span style="color: #00af00;">let</span> ((i (yyhash--lookup key yh nil)))
    (<span style="color: #00af00;">if</span> (&gt;= i 0) (yyhash--value yh i) default)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org1b7829e" class="outline-4">
<h4 id="org1b7829e"><span class="section-number-4">5.3.2</span> 清空</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
移除操作比清空操作要复杂一点，因为它要负责管理静态链表。我们先从清空操作开始。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00af00;">static</span> <span style="color: #18b2b2;">void</span>
<span style="color: #ef2929;">hash_clear</span> (<span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>)
{
  <span style="color: #00af00;">if</span> (h-&gt;count &gt; 0)
    {
      <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">size</span> = HASH_TABLE_SIZE (h);
      <span style="color: #00af00;">if</span> (<span style="color: #cc0000;">!</span>hash_rehash_needed_p (h))
        memclear (XVECTOR (h-&gt;hash)-&gt;contents, size * word_size);
      <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">i</span> = 0; i &lt; size; i++)
        {
          set_hash_next_slot (h, i, i &lt; size - 1 ? i + 1 : -1);
          set_hash_key_slot (h, i, Qunbound);
          set_hash_value_slot (h, i, Qnil);
        }

      <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">i</span> = 0; i &lt; ASIZE (h-&gt;index); i++)
        ASET (h-&gt;index, i, make_fixnum (-1));

      h-&gt;next_free = 0;
      h-&gt;count = 0;
    }
}
</pre>
</div>

<p>
以下是 elisp 实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-clr</span> (yh)
  <span style="color: #cc0000;">"clear headtable"</span>
  (<span style="color: #00af00;">when</span> (&gt; (yyhash-count yh) 0)
    (<span style="color: #00af00;">let</span> ((size (yyhash-size yh))
          (isize (yyhash--isize yh)))
      (<span style="color: #00af00;">cl-loop</span> for i below size
               do (yyhash--hash-setv yh i nil)
               do (yyhash--next-setv yh i (+ i 1))
               do (yyhash--key-and-value-setv yh (* 2 i) nil)
               do (yyhash--key-and-value-setv yh (1+ (* 2 i)) nil)
               finally do (yyhash--next-setv yh (1- size) -1))
      (<span style="color: #00af00;">cl-loop</span> for i below isize
               do (yyhash--index-setv yh i -1))
      (<span style="color: #00af00;">setf</span> (yyhash--s-next-free yh) 0)
      (<span style="color: #00af00;">setf</span> (yyhash--s-count yh) 0)
      yh)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org63c3867" class="outline-4">
<h4 id="org63c3867"><span class="section-number-4">5.3.3</span> 删除</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
接下来是删除操作，原实现有点长，这里就不贴出来了，它的位置是 fns.c 的 4375 行。
</p>

<p>
这段代码稍微有点长，为了避免名字冲突使用了相当长的函数名和变量名。但是它的核心非常简单，就是单链表的删除操作。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-rem</span> (key yh)
  <span style="color: #cc0000;">"rem key's entry from yh, or do nothing if not found"</span>
  (<span style="color: #00af00;">let*</span> ((hash-code (yyhash--hashfn key 0))
         (start-id (% hash-code (yyhash--isize yh)))
         (prev -1)
         (fd (<span style="color: #00af00;">do</span> ((i (yyhash--index-getv yh start-id)
                     (yyhash--next-getv yh i)))
                 ((<span style="color: #00af00;">or</span> (&lt; i 0)
                      (<span style="color: #00af00;">and</span> (equal key (yyhash--key yh i))
                           (= hash-code (yyhash--hash-getv yh i))))
                  i)
               (<span style="color: #00af00;">setq</span> prev i))))
    (<span style="color: #00af00;">when</span> (&gt;= fd 0)
      (<span style="color: #00af00;">if</span> (&lt; prev 0)
          (yyhash--index-setv yh start-id (yyhash--next-getv yh fd))
        (yyhash--next-setv yh prev (yyhash--next-getv yh fd)))
      (yyhash--key-and-value-setv yh (* fd 2) nil)
      (yyhash--key-and-value-setv yh (1+ (* fd 2)) nil)
      (yyhash--hash-setv yh fd nil)
      (yyhash--next-setv yh fd (yyhash--s-next-free yh))
      (<span style="color: #00af00;">setf</span> (yyhash--s-next-free yh) fd)
      (<span style="color: #00af00;">cl-decf</span> (yyhash--s-count yh))
      (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (&gt;= (yyhash-count yh) 0)))
    nil))
</pre>
</div>
</div>
</div>


<div id="outline-container-org931af12" class="outline-4">
<h4 id="org931af12"><span class="section-number-4">5.3.4</span> 遍历</h4>
<div class="outline-text-4" id="text-5-3-4">
<p>
最后是哈希表的遍历，由于在 elisp 中拿不到 unbound 值，所以我只能用键 nil 来代表空的 entry 了。这样一来我们也就没办法使用 nil 来作为键了。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 5033</span>
DEFUN (<span style="color: #ff1f8b;">"maphash"</span>, Fmaphash, Smaphash, 2, 2, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Call FUNCTION for all entries in hash table TABLE.</span>
<span style="color: #b2b2b2; font-style: italic;">FUNCTION is called with two arguments, KEY and VALUE.</span>
<span style="color: #b2b2b2; font-style: italic;">`maphash' always returns nil.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">function</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">table</span>)
{
  <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span> = check_hash_table (table);

  <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">i</span> = 0; i &lt; HASH_TABLE_SIZE (h); ++i)
    {
      <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">k</span> = HASH_KEY (h, i);
      <span style="color: #00af00;">if</span> (<span style="color: #cc0000;">!</span>EQ (k, Qunbound))
        call2 (function, k, HASH_VALUE (h, i));
    }

  <span style="color: #00af00;">return</span> Qnil;
}
</pre>
</div>

<p>
以下是 elisp 实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-map</span> (fn yh)
  <span style="color: #cc0000;">"use function fn to map hashtable"</span>
  (<span style="color: #00af00;">let*</span> ((k-v (yyhash--s-key-and-value yh))
         (len (yyhash-size yh)))
    (<span style="color: #00af00;">do</span> ((i 0 (+ i 2))
         (j 1 (+ j 2))
         (k 0 (+ k 1)))
        ((= k len))
      (<span style="color: #00af00;">and</span> (not (null (aref k-v i)))
           (funcall fn (aref k-v i) (aref k-v j))))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org6725542" class="outline-3">
<h3 id="org6725542"><span class="section-number-3">5.4</span> 哈希表的添加</h3>
<div class="outline-text-3" id="text-5-4">
<p>
添加是一个比较麻烦的步骤，因为它需要考虑扩容和管理链表等问题。咱们先实现放入操作，在放入之前需要使用 <code>maybe_resize_hash_table</code> 检查哈希表是否需要扩容。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 4343</span>
<span style="color: #18b2b2;">ptrdiff_t</span>
<span style="color: #ef2929;">hash_put</span> (<span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">value</span>,
          <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">hash</span>)
{
  <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">start_of_bucket</span>, <span style="color: #ff8700;">i</span>;

  hash_rehash_if_needed (h);

  <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Increment count after resizing because resizing may fail.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>
  maybe_resize_hash_table (h);
  h-&gt;count++;

  <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Store key/value in the key_and_value vector.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>
  i = h-&gt;next_free;
  eassert (NILP (HASH_HASH (h, i)));
  eassert (EQ (Qunbound, (HASH_KEY (h, i))));
  h-&gt;next_free = HASH_NEXT (h, i);
  set_hash_key_slot (h, i, key);
  set_hash_value_slot (h, i, value);

  <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Remember its hash code.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>
  set_hash_hash_slot (h, i, hash);

  <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Add new entry to its collision chain.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>
  start_of_bucket = XUFIXNUM (hash) % ASIZE (h-&gt;index);
  set_hash_next_slot (h, i, HASH_INDEX (h, start_of_bucket));
  set_hash_index_slot (h, start_of_bucket, i);
  <span style="color: #00af00;">return</span> i;
}
<span style="color: #b2b2b2; font-style: italic;">//</span><span style="color: #b2b2b2; font-style: italic;">fns.c 5002</span>
DEFUN (<span style="color: #ff1f8b;">"puthash"</span>, Fputhash, Sputhash, 3, 3, 0,
       doc: <span style="color: #b2b2b2; font-style: italic;">/* </span><span style="color: #b2b2b2; font-style: italic;">Associate KEY with VALUE in hash table TABLE.</span>
<span style="color: #b2b2b2; font-style: italic;">If KEY is already present in table, replace its current value with</span>
<span style="color: #b2b2b2; font-style: italic;">VALUE.  In any case, return VALUE.</span><span style="color: #b2b2b2; font-style: italic;">  */</span>)
  (<span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">key</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">value</span>, <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">table</span>)
{
  <span style="color: #00af00;">struct</span> <span style="color: #18b2b2;">Lisp_Hash_Table</span> *<span style="color: #ff8700;">h</span> = check_hash_table (table);
  check_mutable_hash_table (table, h);

  <span style="color: #18b2b2;">Lisp_Object</span> <span style="color: #ff8700;">hash</span>;
  <span style="color: #18b2b2;">ptrdiff_t</span> <span style="color: #ff8700;">i</span> = hash_lookup (h, key, &amp;hash);
  <span style="color: #00af00;">if</span> (i &gt;= 0)
    set_hash_value_slot (h, i, value);
  <span style="color: #00af00;">else</span>
    hash_put (h, key, value, hash);

  <span style="color: #00af00;">return</span> value;
}
</pre>
</div>

<p>
下面是放入操作的 elisp 实现：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--putnew</span> (key val yh hash)
  <span style="color: #cc0000;">"add new item to hashtable"</span>
  (yyhash--maybe-resize yh)
  (<span style="color: #00af00;">incf</span> (yyhash--s-count yh))
  (<span style="color: #00af00;">let</span> ((i (yyhash--s-next-free yh))
        (start-id (% hash (yyhash--isize yh))))
    (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (null (yyhash--hash-getv yh i)))
    (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (null (yyhash--key yh i)))
    (<span style="color: #00af00;">setf</span> (yyhash--s-next-free yh) (yyhash--next-getv yh i))
    (yyhash--key-and-value-setv yh (* i 2) key)
    (yyhash--key-and-value-setv yh (1+ (* i 2)) val)
    (yyhash--hash-setv yh i hash)
    (yyhash--next-setv yh i (yyhash--index-getv yh start-id))
    (yyhash--index-setv yh start-id i)
    i))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash-put</span> (key val yh)
  <span style="color: #cc0000;">"put k-v entry to hashtable, if key exist's, use val repalce oldval"</span>
  (<span style="color: #cc0000; font-weight: bold;">cl-assert</span> (not (null key)))
  (<span style="color: #00af00;">let*</span> ((hash-c (list nil))
         (i (yyhash--lookup key yh hash-c))
         (hash (car hash-c)))
    (<span style="color: #00af00;">if</span> (&gt;= i 0) (yyhash--key-and-value-setv yh (1+ (* i 2)) val)
      (yyhash--putnew key val yh hash))
    val))
</pre>
</div>

<p>
当哈希表被填满时就需要扩容了，此时 entry 个数等于哈希表大小。当哈希表满时， <code>next-free</code> 的值应该为 -1。 <code>maybe_resize_hash_table</code> 位于 fns.c 的第 4188 行，太长了就不放了。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--vec-copy</span> (new old len)
  <span style="color: #cc0000;">"copy old vec's values to new vec"</span>
  (<span style="color: #00af00;">cl-loop</span> for i below len
           do (aset new i (aref old i)))
  new)

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">yyhash--maybe-resize</span> (yh)
  <span style="color: #cc0000;">"extend hashtables' size"</span>
  (<span style="color: #00af00;">when</span> (&lt; (yyhash--s-next-free yh) 0)
    (<span style="color: #00af00;">let*</span> ((old-size (yyhash-size yh))
           (new-size (floor (* old-size yyhash--rehash-size))))
      (<span style="color: #00af00;">when</span> (&gt; new-size yyhash--biggest)
        (<span style="color: #00af00;">setq</span> new-size yyhash-biggest))
      (<span style="color: #00af00;">when</span> (= old-size yyhash--biggest)
        (<span style="color: #cc0000; font-weight: bold;">error</span> <span style="color: #ff1f8b;">"yyhash is up to biggest"</span>))
      (<span style="color: #00af00;">let*</span> ((next-n (yyhash--vec-copy
                      (make-vector new-size -1)
                      (yyhash--s-next yh) old-size))
             (k-v-n (yyhash--vec-copy
                     (make-vector (* 2 new-size) nil)
                     (yyhash--s-key-and-value yh) (* old-size 2)))
             (hash-n (yyhash--vec-copy
                      (make-vector new-size nil)
                      (yyhash--s-hash yh) old-size))
             (index-size (yyhash--next-almost-prime
                          (floor (/ new-size yyhash--rehash-threshold))))
             (index-n (make-vector index-size -1)))
        (<span style="color: #00af00;">do</span> ((i old-size (1+ i)))
            ((= i (1- new-size)) (aset next-n i -1))
          (aset next-n i (+ i 1)))
        (<span style="color: #00af00;">setf</span> (yyhash--s-index yh) index-n)
        (<span style="color: #00af00;">setf</span> (yyhash--s-key-and-value yh) k-v-n)
        (<span style="color: #00af00;">setf</span> (yyhash--s-hash yh) hash-n)
        (<span style="color: #00af00;">setf</span> (yyhash--s-next yh) next-n)
        (<span style="color: #00af00;">setf</span> (yyhash--s-next-free yh) old-size)

        (<span style="color: #00af00;">do</span> ((i 0 (1+ i)))
            ((= i old-size))
          (<span style="color: #00af00;">let*</span> ((hash-code (yyhash--hash-getv yh i))
                 (start-id (% hash-code index-size)))
            (yyhash--next-setv yh i (yyhash--index-getv yh start-id))
            (yyhash--index-setv yh start-id i)))))))
</pre>
</div>

<p>
这样一来，我们就完成了所有函数的编写。
</p>
</div>
</div>


<div id="outline-container-org508281c" class="outline-3">
<h3 id="org508281c"><span class="section-number-3">5.5</span> 测试与小结</h3>
<div class="outline-text-3" id="text-5-5">
<p>
本哈希表的实现和测试我整合后放在 <a href="https://gist.github.com/include-yy/4b30d26e2a8b8bcdd46c1bcd717b3756">gist</a> 上了，可以方便地获取，这里就不放测试了，放张图说明测试的成功吧（毕竟测试代码也有近两百行&#x2026;&#x2026;）。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./6.PNG" alt="6.PNG" /></td>
</tr>
</tbody>
</table>

<p>
代码也可以通过下载来获得：<a href="./yyhash.el">yyhash</a> <a href="./yyhash-test.el">test</a>
</p>

<p>
写代码的时候还想着写完后大发一顿感慨，但是写完了之后只想睡觉（笑）。本来准备再介绍一下 emacs 实现的详细位置，但是我已经在上面的代码中标注出源代码所在行数了，想了想没必要。
</p>

<p>
这次写的浮点转 8 字节数的代码算是意外收获，毕竟以前没碰到过使用场景。这里有个浮点转字节的<a href="https://www.binaryconvert.com/convert_double.html">网站</a>，我使用 <code>yyhash-float2list</code> 尝试了几个值，和网站的结果吻合的很好。
</p>

<p>
这里只介绍了拉链法，开放寻址法只在冲突解决上与拉链法不同，这里有篇文章可以参考下：<a href="https://webfront.dev/posts/hash-table-in-c/">https://webfront.dev/posts/hash-table-in-c/</a> 。在一众拉链法中找一个完整实现的开放寻址法还真不容易。
</p>
</div>
</div>
</div>

<div id="outline-container-org64300c6" class="outline-2">
<h2 id="org64300c6"><span class="section-number-2">6</span> 后记</h2>
<div class="outline-text-2" id="text-6">
<p>
这个摊子铺的大了点，本来只是准备记录一下 emacs 中哈希函数的用法，不过学学哈希表实现也算是有所收获。
</p>

<p>
本来还准备介绍一些用在其他地方的哈希函数，比如 MD5, SHA1 等，但是这足够再写上几篇文章了，而且它们的用途也不是用来产生供哈希表使用的哈希值，还是算了。
</p>

<p>
2022 新年快乐。
</p>

<p>
<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzEwNzcxMzE3.jpg" alt="load failed"></div><div class="yyimgcomment">lady whitestone</div>
</p>

<p>
<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzE0MjkxMTU=.jpg" alt="load failed"></div>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Data_type">https://en.wikipedia.org/wiki/Data_type</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara"><a href="https://dl.acm.org/doi/10.1145/984344.807133">https://dl.acm.org/doi/10.1145/984344.807133</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Abstract_data_type">https://en.wikipedia.org/wiki/Abstract_data_type</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Data_structure">https://en.wikipedia.org/wiki/Data_structure</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Perfect_hash_function">https://en.wikipedia.org/wiki/Perfect_hash_function</a></p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr class="Solid">
<p>Create Date: 2021-10-09 Sat 17:06</p> <p>Last modified: 2022-01-24 Mon 23:00</p>
<p>Creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>

<p style="text-align:center;">
  <a href="https://beian.miit.gov.cn/">京ICP备2021021729号</a>
</p>

<p style="text-align:center;">
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
  </a><br />
  本作品采用
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    知识共享署名 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
</body>
</html>
